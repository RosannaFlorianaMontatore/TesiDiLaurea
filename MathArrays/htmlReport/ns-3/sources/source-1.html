


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AccurateMath</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.apache.commons.math4.legacy.core.jdkmath</a>
</div>

<h1>Coverage Summary for Class: AccurateMath (org.apache.commons.math4.legacy.core.jdkmath)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AccurateMath</td>
<td class="coverageStat">
  <span class="percent">
    6,7%
  </span>
  <span class="absValue">
    (6/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1,8%
  </span>
  <span class="absValue">
    (26/1477)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AccurateMath$CodyWaite</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AccurateMath$ExpFracTable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AccurateMath$ExpIntTable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AccurateMath$lnMant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AccurateMath$Split</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    5,7%
  </span>
  <span class="absValue">
    (6/105)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    1,7%
  </span>
  <span class="absValue">
    (26/1541)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Licensed to the Apache Software Foundation (ASF) under one or more
&nbsp; * contributor license agreements.  See the NOTICE file distributed with
&nbsp; * this work for additional information regarding copyright ownership.
&nbsp; * The ASF licenses this file to You under the Apache License, Version 2.0
&nbsp; * (the &quot;License&quot;); you may not use this file except in compliance with
&nbsp; * the License.  You may obtain a copy of the License at
&nbsp; *
&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package org.apache.commons.math4.legacy.core.jdkmath;
&nbsp;
&nbsp;import java.io.PrintStream;
&nbsp;
&nbsp;import org.apache.commons.numbers.core.Precision;
&nbsp;import org.apache.commons.math4.legacy.exception.MathArithmeticException;
&nbsp;import org.apache.commons.math4.legacy.exception.util.LocalizedFormats;
&nbsp;
&nbsp;/**
&nbsp; * Portable alternative to {@link Math} and {@link StrictMath}.
&nbsp; * &lt;p&gt;
&nbsp; * Caveat: At the time of implementation, the {@code AccurateMath} functions
&nbsp; * were often faster and/or more accurate than their JDK equivalent.
&nbsp; * Nowadays, it would not be surprising that they are always slower (due
&nbsp; * to the various JVM optimizations that have appeared since Java 5).
&nbsp; * However, any change to this class should ensure that the current
&nbsp; * accuracy is not lost.
&nbsp; * &lt;p&gt;
&nbsp; * AccurateMath is a drop-in replacement for both Math and StrictMath. This
&nbsp; * means that for any method in Math (say {@code Math.sin(x)} or
&nbsp; * {@code Math.cbrt(y)}), user can directly change the class and use the
&nbsp; * methods as is (using {@code AccurateMath.sin(x)} or {@code AccurateMath.cbrt(y)}
&nbsp; * in the previous example).
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * AccurateMath speed is achieved by relying heavily on optimizing compilers
&nbsp; * to native code present in many JVMs today and use of large tables.
&nbsp; * The larger tables are lazily initialized on first use, so that the setup
&nbsp; * time does not penalize methods that don&#39;t need them.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Note that AccurateMath is
&nbsp; * extensively used inside Apache Commons Math, so by calling some algorithms,
&nbsp; * the overhead when the tables need to be initialized will occur
&nbsp; * regardless of the end-user calling AccurateMath methods directly or not.
&nbsp; * Performance figures for a specific JVM and hardware can be evaluated by
&nbsp; * running the AccurateMathTestPerformance tests in the test directory of the source
&nbsp; * distribution.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * AccurateMath accuracy should be mostly independent of the JVM as it relies only
&nbsp; * on IEEE-754 basic operations and on embedded tables. Almost all operations
&nbsp; * are accurate to about 0.5 ulp throughout the domain range. This statement,
&nbsp; * of course is only a rough global observed behavior, it is &lt;em&gt;not&lt;/em&gt; a
&nbsp; * guarantee for &lt;em&gt;every&lt;/em&gt; double numbers input (see William Kahan&#39;s &lt;a
&nbsp; * href=&quot;http://en.wikipedia.org/wiki/Rounding#The_table-maker.27s_dilemma&quot;&gt;Table
&nbsp; * Maker&#39;s Dilemma&lt;/a&gt;).
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * AccurateMath additionally implements the following methods not found in Math/StrictMath:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;{@link #asinh(double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #acosh(double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #atanh(double)}&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * The following methods are found in Math/StrictMath since 1.6 only, they are provided
&nbsp; * by AccurateMath even in 1.5 Java virtual machines
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;{@link #copySign(double, double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #getExponent(double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #nextAfter(double,double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #nextUp(double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #scalb(double, int)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #copySign(float, float)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #getExponent(float)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #nextAfter(float,double)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #nextUp(float)}&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link #scalb(float, int)}&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * @since 2.2
&nbsp; */
&nbsp;public final class AccurateMath {
&nbsp;    /** Archimede&#39;s constant PI, ratio of circle circumference to diameter. */
&nbsp;    public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
&nbsp;
&nbsp;    /** Napier&#39;s constant e, base of the natural logarithm. */
&nbsp;    public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;
&nbsp;
&nbsp;    /** Index of exp(0) in the array of integer exponentials. */
&nbsp;    static final int EXP_INT_TABLE_MAX_INDEX = 750;
&nbsp;    /** Length of the array of integer exponentials. */
&nbsp;    static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;
&nbsp;    /** Logarithm table length. */
&nbsp;    static final int LN_MANT_LEN = 1024;
&nbsp;    /** Exponential fractions table length. */
&nbsp;    static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024
&nbsp;
&nbsp;    /** StrictMath.log(Double.MAX_VALUE): {@value}. */
<b class="fc">&nbsp;    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);</b>
&nbsp;
&nbsp;    /** Indicator for tables initialization.
&nbsp;     * &lt;p&gt;
&nbsp;     * This compile-time constant should be set to true only if one explicitly
&nbsp;     * wants to compute the tables at class loading time instead of using the
&nbsp;     * already computed ones provided as literal arrays below.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;
&nbsp;
&nbsp;    /** log(2) (high bits). */
&nbsp;    private static final double LN_2_A = 0.693147063255310059;
&nbsp;
&nbsp;    /** log(2) (low bits). */
&nbsp;    private static final double LN_2_B = 1.17304635250823482e-7;
&nbsp;
&nbsp;    /** Coefficients for log, when input 0.99 &lt; x &lt; 1.01. */
<b class="fc">&nbsp;    private static final double[][] LN_QUICK_COEF = {</b>
&nbsp;        {1.0, 5.669184079525E-24},
&nbsp;        {-0.25, -0.25},
&nbsp;        {0.3333333134651184, 1.986821492305628E-8},
&nbsp;        {-0.25, -6.663542893624021E-14},
&nbsp;        {0.19999998807907104, 1.1921056801463227E-8},
&nbsp;        {-0.1666666567325592, -7.800414592973399E-9},
&nbsp;        {0.1428571343421936, 5.650007086920087E-9},
&nbsp;        {-0.12502530217170715, -7.44321345601866E-11},
&nbsp;        {0.11113807559013367, 9.219544613762692E-9},
&nbsp;    };
&nbsp;
&nbsp;    /** Coefficients for log in the range of 1.0 &lt; x &lt; 1.0 + 2^-10. */
<b class="fc">&nbsp;    private static final double[][] LN_HI_PREC_COEF = {</b>
&nbsp;        {1.0, -6.032174644509064E-23},
&nbsp;        {-0.25, -0.25},
&nbsp;        {0.3333333134651184, 1.9868161777724352E-8},
&nbsp;        {-0.2499999701976776, -2.957007209750105E-8},
&nbsp;        {0.19999954104423523, 1.5830993332061267E-10},
&nbsp;        {-0.16624879837036133, -2.6033824355191673E-8}
&nbsp;    };
&nbsp;
&nbsp;    /** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */
&nbsp;    private static final int SINE_TABLE_LEN = 14;
&nbsp;
&nbsp;    /** Sine table (high bits). */
<b class="fc">&nbsp;    private static final double[] SINE_TABLE_A =</b>
&nbsp;        {
&nbsp;        +0.0d,
&nbsp;        +0.1246747374534607d,
&nbsp;        +0.24740394949913025d,
&nbsp;        +0.366272509098053d,
&nbsp;        +0.4794255495071411d,
&nbsp;        +0.5850973129272461d,
&nbsp;        +0.6816387176513672d,
&nbsp;        +0.7675435543060303d,
&nbsp;        +0.8414709568023682d,
&nbsp;        +0.902267575263977d,
&nbsp;        +0.9489846229553223d,
&nbsp;        +0.9808930158615112d,
&nbsp;        +0.9974949359893799d,
&nbsp;        +0.9985313415527344d,
&nbsp;    };
&nbsp;
&nbsp;    /** Sine table (low bits). */
<b class="fc">&nbsp;    private static final double[] SINE_TABLE_B =</b>
&nbsp;        {
&nbsp;        +0.0d,
&nbsp;        -4.068233003401932E-9d,
&nbsp;        +9.755392680573412E-9d,
&nbsp;        +1.9987994582857286E-8d,
&nbsp;        -1.0902938113007961E-8d,
&nbsp;        -3.9986783938944604E-8d,
&nbsp;        +4.23719669792332E-8d,
&nbsp;        -5.207000323380292E-8d,
&nbsp;        +2.800552834259E-8d,
&nbsp;        +1.883511811213715E-8d,
&nbsp;        -3.5997360512765566E-9d,
&nbsp;        +4.116164446561962E-8d,
&nbsp;        +5.0614674548127384E-8d,
&nbsp;        -1.0129027912496858E-9d,
&nbsp;    };
&nbsp;
&nbsp;    /** Cosine table (high bits). */
<b class="fc">&nbsp;    private static final double[] COSINE_TABLE_A =</b>
&nbsp;        {
&nbsp;        +1.0d,
&nbsp;        +0.9921976327896118d,
&nbsp;        +0.9689123630523682d,
&nbsp;        +0.9305076599121094d,
&nbsp;        +0.8775825500488281d,
&nbsp;        +0.8109631538391113d,
&nbsp;        +0.7316888570785522d,
&nbsp;        +0.6409968137741089d,
&nbsp;        +0.5403022766113281d,
&nbsp;        +0.4311765432357788d,
&nbsp;        +0.3153223395347595d,
&nbsp;        +0.19454771280288696d,
&nbsp;        +0.07073719799518585d,
&nbsp;        -0.05417713522911072d,
&nbsp;    };
&nbsp;
&nbsp;    /** Cosine table (low bits). */
<b class="fc">&nbsp;    private static final double[] COSINE_TABLE_B =</b>
&nbsp;        {
&nbsp;        +0.0d,
&nbsp;        +3.4439717236742845E-8d,
&nbsp;        +5.865827662008209E-8d,
&nbsp;        -3.7999795083850525E-8d,
&nbsp;        +1.184154459111628E-8d,
&nbsp;        -3.43338934259355E-8d,
&nbsp;        +1.1795268640216787E-8d,
&nbsp;        +4.438921624363781E-8d,
&nbsp;        +2.925681159240093E-8d,
&nbsp;        -2.6437112632041807E-8d,
&nbsp;        +2.2860509143963117E-8d,
&nbsp;        -4.813899778443457E-9d,
&nbsp;        +3.6725170580355583E-9d,
&nbsp;        +2.0217439756338078E-10d,
&nbsp;    };
&nbsp;
&nbsp;
&nbsp;    /** Tangent table, used by atan() (high bits). */
<b class="fc">&nbsp;    private static final double[] TANGENT_TABLE_A =</b>
&nbsp;        {
&nbsp;        +0.0d,
&nbsp;        +0.1256551444530487d,
&nbsp;        +0.25534194707870483d,
&nbsp;        +0.3936265707015991d,
&nbsp;        +0.5463024377822876d,
&nbsp;        +0.7214844226837158d,
&nbsp;        +0.9315965175628662d,
&nbsp;        +1.1974215507507324d,
&nbsp;        +1.5574076175689697d,
&nbsp;        +2.092571258544922d,
&nbsp;        +3.0095696449279785d,
&nbsp;        +5.041914939880371d,
&nbsp;        +14.101419448852539d,
&nbsp;        -18.430862426757812d,
&nbsp;    };
&nbsp;
&nbsp;    /** Tangent table, used by atan() (low bits). */
<b class="fc">&nbsp;    private static final double[] TANGENT_TABLE_B =</b>
&nbsp;        {
&nbsp;        +0.0d,
&nbsp;        -7.877917738262007E-9d,
&nbsp;        -2.5857668567479893E-8d,
&nbsp;        +5.2240336371356666E-9d,
&nbsp;        +5.206150291559893E-8d,
&nbsp;        +1.8307188599677033E-8d,
&nbsp;        -5.7618793749770706E-8d,
&nbsp;        +7.848361555046424E-8d,
&nbsp;        +1.0708593250394448E-7d,
&nbsp;        +1.7827257129423813E-8d,
&nbsp;        +2.893485277253286E-8d,
&nbsp;        +3.1660099222737955E-7d,
&nbsp;        +4.983191803254889E-7d,
&nbsp;        -3.356118100840571E-7d,
&nbsp;    };
&nbsp;
&nbsp;    /** Bits of 1/(2*pi), need for reducePayneHanek(). */
<b class="fc">&nbsp;    private static final long[] RECIP_2PI = new long[] {</b>
&nbsp;        (0x28be60dbL &lt;&lt; 32) | 0x9391054aL,
&nbsp;        (0x7f09d5f4L &lt;&lt; 32) | 0x7d4d3770L,
&nbsp;        (0x36d8a566L &lt;&lt; 32) | 0x4f10e410L,
&nbsp;        (0x7f9458eaL &lt;&lt; 32) | 0xf7aef158L,
&nbsp;        (0x6dc91b8eL &lt;&lt; 32) | 0x909374b8L,
&nbsp;        (0x01924bbaL &lt;&lt; 32) | 0x82746487L,
&nbsp;        (0x3f877ac7L &lt;&lt; 32) | 0x2c4a69cfL,
&nbsp;        (0xba208d7dL &lt;&lt; 32) | 0x4baed121L,
&nbsp;        (0x3a671c09L &lt;&lt; 32) | 0xad17df90L,
&nbsp;        (0x4e64758eL &lt;&lt; 32) | 0x60d4ce7dL,
&nbsp;        (0x272117e2L &lt;&lt; 32) | 0xef7e4a0eL,
&nbsp;        (0xc7fe25ffL &lt;&lt; 32) | 0xf7816603L,
&nbsp;        (0xfbcbc462L &lt;&lt; 32) | 0xd6829b47L,
&nbsp;        (0xdb4d9fb3L &lt;&lt; 32) | 0xc9f2c26dL,
&nbsp;        (0xd3d18fd9L &lt;&lt; 32) | 0xa797fa8bL,
&nbsp;        (0x5d49eeb1L &lt;&lt; 32) | 0xfaf97c5eL,
&nbsp;        (0xcf41ce7dL &lt;&lt; 32) | 0xe294a4baL,
&nbsp;        (0x9afed7ecL &lt;&lt; 32)};
&nbsp;
&nbsp;    /** Bits of pi/4, need for reducePayneHanek(). */
<b class="fc">&nbsp;    private static final long[] PI_O_4_BITS = new long[] {</b>
&nbsp;        (0xc90fdaa2L &lt;&lt; 32) | 0x2168c234L,
&nbsp;        (0xc4c6628bL &lt;&lt; 32) | 0x80dc1cd1L };
&nbsp;
&nbsp;    /** Eighths.
&nbsp;     * This is used by sinQ, because its faster to do a table lookup than
&nbsp;     * a multiply in this time-critical routine
&nbsp;     */
<b class="fc">&nbsp;    private static final double[] EIGHTHS = {</b>
&nbsp;        0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};
&nbsp;
&nbsp;    /** Table of 2^((n+2)/3). */
<b class="fc">&nbsp;    private static final double[] CBRTTWO = {0.6299605249474366,</b>
&nbsp;                                             0.7937005259840998,
&nbsp;                                             1.0,
&nbsp;                                             1.2599210498948732,
&nbsp;                                             1.5874010519681994};
&nbsp;
&nbsp;    /*
&nbsp;     *  There are 52 bits in the mantissa of a double.
&nbsp;     *  For additional precision, the code splits double numbers into two parts,
&nbsp;     *  by clearing the low order 30 bits if possible, and then performs the arithmetic
&nbsp;     *  on each half separately.
&nbsp;     */
&nbsp;
&nbsp;    /**
&nbsp;     * 0x40000000 - used to split a double into two parts, both with the low order bits cleared.
&nbsp;     * Equivalent to 2^30.
&nbsp;     */
&nbsp;    private static final long HEX_40000000 = 0x40000000L; // 1073741824L
&nbsp;
&nbsp;    /** Mask used to clear low order 30 bits. */
&nbsp;    private static final long MASK_30BITS = -1L - (HEX_40000000 - 1); // 0xFFFFFFFFC0000000L;
&nbsp;
&nbsp;    /** Mask used to clear the non-sign part of an int. */
&nbsp;    private static final int MASK_NON_SIGN_INT = 0x7fffffff;
&nbsp;
&nbsp;    /** Mask used to clear the non-sign part of a long. */
&nbsp;    private static final long MASK_NON_SIGN_LONG = 0x7fffffffffffffffL;
&nbsp;
&nbsp;    /** Mask used to extract exponent from double bits. */
&nbsp;    private static final long MASK_DOUBLE_EXPONENT = 0x7ff0000000000000L;
&nbsp;
&nbsp;    /** Mask used to extract mantissa from double bits. */
&nbsp;    private static final long MASK_DOUBLE_MANTISSA = 0x000fffffffffffffL;
&nbsp;
&nbsp;    /** Mask used to add implicit high order bit for normalized double. */
&nbsp;    private static final long IMPLICIT_HIGH_BIT = 0x0010000000000000L;
&nbsp;
&nbsp;    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite. */
&nbsp;    private static final double TWO_POWER_52 = 4503599627370496.0;
&nbsp;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_3 = 1d / 3d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_5 = 1d / 5d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_7 = 1d / 7d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_9 = 1d / 9d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_11 = 1d / 11d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_13 = 1d / 13d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_15 = 1d / 15d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_17 = 1d / 17d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_3_4 = 3d / 4d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_15_16 = 15d / 16d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_13_14 = 13d / 14d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_11_12 = 11d / 12d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_9_10 = 9d / 10d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_7_8 = 7d / 8d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_5_6 = 5d / 6d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_2 = 1d / 2d;
&nbsp;    /** Constant: {@value}. */
&nbsp;    private static final double F_1_4 = 1d / 4d;
&nbsp;
&nbsp;    /**
&nbsp;     * Private Constructor.
&nbsp;     */
&nbsp;    private AccurateMath() {}
&nbsp;
&nbsp;    // Generic helper methods
&nbsp;
&nbsp;    /**
&nbsp;     * Get the high order bits from the mantissa.
&nbsp;     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers
&nbsp;     *
&nbsp;     * @param d the value to split
&nbsp;     * @return the high order part of the mantissa
&nbsp;     */
&nbsp;    private static double doubleHighPart(double d) {
<b class="nc">&nbsp;        if (d &gt; -Precision.SAFE_MIN &amp;&amp; d &lt; Precision.SAFE_MIN) {</b>
<b class="nc">&nbsp;            return d; // These are un-normalised - don&#39;t try to convert</b>
&nbsp;        }
<b class="nc">&nbsp;        long xl = Double.doubleToRawLongBits(d); // can take raw bits because just gonna convert it back</b>
<b class="nc">&nbsp;        xl &amp;= MASK_30BITS; // Drop low order bits</b>
<b class="nc">&nbsp;        return Double.longBitsToDouble(xl);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the square root of a number.
&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link Math#sqrt}
&nbsp;     * @param a number on which evaluation is done
&nbsp;     * @return square root of a
&nbsp;     */
&nbsp;    public static double sqrt(final double a) {
<b class="fc">&nbsp;        return Math.sqrt(a);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the hyperbolic cosine of a number.
&nbsp;     * @param x number on which evaluation is done
&nbsp;     * @return hyperbolic cosine of x
&nbsp;     */
&nbsp;    public static double cosh(double x) {
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        // cosh[z] = (exp(z) + exp(-z))/2
&nbsp;
&nbsp;        // for numbers with magnitude 20 or so,
&nbsp;        // exp(-z) can be ignored in comparison with exp(z)
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 20) {</b>
<b class="nc">&nbsp;            if (x &gt;= LOG_MAX_VALUE) {</b>
&nbsp;                // Avoid overflow (MATH-905).
<b class="nc">&nbsp;                final double t = exp(0.5 * x);</b>
<b class="nc">&nbsp;                return (0.5 * t) * t;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return 0.5 * exp(x);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (x &lt; -20) {</b>
<b class="nc">&nbsp;            if (x &lt;= -LOG_MAX_VALUE) {</b>
&nbsp;                // Avoid overflow (MATH-905).
<b class="nc">&nbsp;                final double t = exp(-0.5 * x);</b>
<b class="nc">&nbsp;                return (0.5 * t) * t;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return 0.5 * exp(-x);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final double[] hiPrec = new double[2];</b>
<b class="nc">&nbsp;        if (x &lt; 0.0) {</b>
<b class="nc">&nbsp;            x = -x;</b>
&nbsp;        }
<b class="nc">&nbsp;        exp(x, 0.0, hiPrec);</b>
&nbsp;
<b class="nc">&nbsp;        double ya = hiPrec[0] + hiPrec[1];</b>
<b class="nc">&nbsp;        double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
&nbsp;
<b class="nc">&nbsp;        double temp = ya * HEX_40000000;</b>
<b class="nc">&nbsp;        double yaa = ya + temp - temp;</b>
<b class="nc">&nbsp;        double yab = ya - yaa;</b>
&nbsp;
&nbsp;        // recip = 1/y
<b class="nc">&nbsp;        double recip = 1.0 / ya;</b>
<b class="nc">&nbsp;        temp = recip * HEX_40000000;</b>
<b class="nc">&nbsp;        double recipa = recip + temp - temp;</b>
<b class="nc">&nbsp;        double recipb = recip - recipa;</b>
&nbsp;
&nbsp;        // Correct for rounding in division
<b class="nc">&nbsp;        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;</b>
&nbsp;        // Account for yb
<b class="nc">&nbsp;        recipb += -yb * recip * recip;</b>
&nbsp;
&nbsp;        // y = y + 1/y
<b class="nc">&nbsp;        temp = ya + recipa;</b>
<b class="nc">&nbsp;        yb += -(temp - ya - recipa);</b>
<b class="nc">&nbsp;        ya = temp;</b>
<b class="nc">&nbsp;        temp = ya + recipb;</b>
<b class="nc">&nbsp;        yb += -(temp - ya - recipb);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        double result = ya + yb;</b>
<b class="nc">&nbsp;        result *= 0.5;</b>
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the hyperbolic sine of a number.
&nbsp;     * @param x number on which evaluation is done
&nbsp;     * @return hyperbolic sine of x
&nbsp;     */
&nbsp;    public static double sinh(double x) {
<b class="nc">&nbsp;        boolean negate = false;</b>
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        // sinh[z] = (exp(z) - exp(-z) / 2
&nbsp;
&nbsp;        // for values of z larger than about 20,
&nbsp;        // exp(-z) can be ignored in comparison with exp(z)
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 20) {</b>
<b class="nc">&nbsp;            if (x &gt;= LOG_MAX_VALUE) {</b>
&nbsp;                // Avoid overflow (MATH-905).
<b class="nc">&nbsp;                final double t = exp(0.5 * x);</b>
<b class="nc">&nbsp;                return (0.5 * t) * t;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return 0.5 * exp(x);</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (x &lt; -20) {</b>
<b class="nc">&nbsp;            if (x &lt;= -LOG_MAX_VALUE) {</b>
&nbsp;                // Avoid overflow (MATH-905).
<b class="nc">&nbsp;                final double t = exp(-0.5 * x);</b>
<b class="nc">&nbsp;                return (-0.5 * t) * t;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return -0.5 * exp(-x);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == 0) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &lt; 0.0) {</b>
<b class="nc">&nbsp;            x = -x;</b>
<b class="nc">&nbsp;            negate = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        double result;
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 0.25) {</b>
<b class="nc">&nbsp;            double[] hiPrec = new double[2];</b>
<b class="nc">&nbsp;            exp(x, 0.0, hiPrec);</b>
&nbsp;
<b class="nc">&nbsp;            double ya = hiPrec[0] + hiPrec[1];</b>
<b class="nc">&nbsp;            double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
&nbsp;
<b class="nc">&nbsp;            double temp = ya * HEX_40000000;</b>
<b class="nc">&nbsp;            double yaa = ya + temp - temp;</b>
<b class="nc">&nbsp;            double yab = ya - yaa;</b>
&nbsp;
&nbsp;            // recip = 1/y
<b class="nc">&nbsp;            double recip = 1.0 / ya;</b>
<b class="nc">&nbsp;            temp = recip * HEX_40000000;</b>
<b class="nc">&nbsp;            double recipa = recip + temp - temp;</b>
<b class="nc">&nbsp;            double recipb = recip - recipa;</b>
&nbsp;
&nbsp;            // Correct for rounding in division
<b class="nc">&nbsp;            recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;</b>
&nbsp;            // Account for yb
<b class="nc">&nbsp;            recipb += -yb * recip * recip;</b>
&nbsp;
<b class="nc">&nbsp;            recipa = -recipa;</b>
<b class="nc">&nbsp;            recipb = -recipb;</b>
&nbsp;
&nbsp;            // y = y + 1/y
<b class="nc">&nbsp;            temp = ya + recipa;</b>
<b class="nc">&nbsp;            yb += -(temp - ya - recipa);</b>
<b class="nc">&nbsp;            ya = temp;</b>
<b class="nc">&nbsp;            temp = ya + recipb;</b>
<b class="nc">&nbsp;            yb += -(temp - ya - recipb);</b>
<b class="nc">&nbsp;            ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;            result = ya + yb;</b>
<b class="nc">&nbsp;            result *= 0.5;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            double[] hiPrec = new double[2];</b>
<b class="nc">&nbsp;            expm1(x, hiPrec);</b>
&nbsp;
<b class="nc">&nbsp;            double ya = hiPrec[0] + hiPrec[1];</b>
<b class="nc">&nbsp;            double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
&nbsp;
&nbsp;            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
<b class="nc">&nbsp;            double denom = 1.0 + ya;</b>
<b class="nc">&nbsp;            double denomr = 1.0 / denom;</b>
<b class="nc">&nbsp;            double denomb = -(denom - 1.0 - ya) + yb;</b>
<b class="nc">&nbsp;            double ratio = ya * denomr;</b>
<b class="nc">&nbsp;            double temp = ratio * HEX_40000000;</b>
<b class="nc">&nbsp;            double ra = ratio + temp - temp;</b>
<b class="nc">&nbsp;            double rb = ratio - ra;</b>
&nbsp;
<b class="nc">&nbsp;            temp = denom * HEX_40000000;</b>
<b class="nc">&nbsp;            double za = denom + temp - temp;</b>
<b class="nc">&nbsp;            double zb = denom - za;</b>
&nbsp;
<b class="nc">&nbsp;            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;</b>
&nbsp;
&nbsp;            // Adjust for yb
<b class="nc">&nbsp;            rb += yb * denomr;                      // numerator</b>
<b class="nc">&nbsp;            rb += -ya * denomb * denomr * denomr;   // denominator</b>
&nbsp;
&nbsp;            // y = y - 1/y
<b class="nc">&nbsp;            temp = ya + ra;</b>
<b class="nc">&nbsp;            yb += -(temp - ya - ra);</b>
<b class="nc">&nbsp;            ya = temp;</b>
<b class="nc">&nbsp;            temp = ya + rb;</b>
<b class="nc">&nbsp;            yb += -(temp - ya - rb);</b>
<b class="nc">&nbsp;            ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;            result = ya + yb;</b>
<b class="nc">&nbsp;            result *= 0.5;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (negate) {</b>
<b class="nc">&nbsp;            result = -result;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the hyperbolic tangent of a number.
&nbsp;     * @param x number on which evaluation is done
&nbsp;     * @return hyperbolic tangent of x
&nbsp;     */
&nbsp;    public static double tanh(double x) {
<b class="nc">&nbsp;        boolean negate = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        // tanh[z] = sinh[z] / cosh[z]
&nbsp;        // = (exp(z) - exp(-z)) / (exp(z) + exp(-z))
&nbsp;        // = (exp(2x) - 1) / (exp(2x) + 1)
&nbsp;
&nbsp;        // for magnitude &gt; 20, sinh[z] == cosh[z] in double precision
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 20.0) {</b>
<b class="nc">&nbsp;            return 1.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &lt; -20) {</b>
<b class="nc">&nbsp;            return -1.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == 0) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &lt; 0.0) {</b>
<b class="nc">&nbsp;            x = -x;</b>
<b class="nc">&nbsp;            negate = true;</b>
&nbsp;        }
&nbsp;
&nbsp;        double result;
<b class="nc">&nbsp;        if (x &gt;= 0.5) {</b>
<b class="nc">&nbsp;            double[] hiPrec = new double[2];</b>
&nbsp;            // tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
<b class="nc">&nbsp;            exp(x * 2.0, 0.0, hiPrec);</b>
&nbsp;
<b class="nc">&nbsp;            double ya = hiPrec[0] + hiPrec[1];</b>
<b class="nc">&nbsp;            double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
&nbsp;
&nbsp;            /* Numerator */
<b class="nc">&nbsp;            double na = -1.0 + ya;</b>
<b class="nc">&nbsp;            double nb = -(na + 1.0 - ya);</b>
<b class="nc">&nbsp;            double temp = na + yb;</b>
<b class="nc">&nbsp;            nb += -(temp - na - yb);</b>
<b class="nc">&nbsp;            na = temp;</b>
&nbsp;
&nbsp;            /* Denominator */
<b class="nc">&nbsp;            double da = 1.0 + ya;</b>
<b class="nc">&nbsp;            double db = -(da - 1.0 - ya);</b>
<b class="nc">&nbsp;            temp = da + yb;</b>
<b class="nc">&nbsp;            db += -(temp - da - yb);</b>
<b class="nc">&nbsp;            da = temp;</b>
&nbsp;
<b class="nc">&nbsp;            temp = da * HEX_40000000;</b>
<b class="nc">&nbsp;            double daa = da + temp - temp;</b>
<b class="nc">&nbsp;            double dab = da - daa;</b>
&nbsp;
&nbsp;            // ratio = na/da
<b class="nc">&nbsp;            double ratio = na / da;</b>
<b class="nc">&nbsp;            temp = ratio * HEX_40000000;</b>
<b class="nc">&nbsp;            double ratioa = ratio + temp - temp;</b>
<b class="nc">&nbsp;            double ratiob = ratio - ratioa;</b>
&nbsp;
&nbsp;            // Correct for rounding in division
<b class="nc">&nbsp;            ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;</b>
&nbsp;
&nbsp;            // Account for nb
<b class="nc">&nbsp;            ratiob += nb / da;</b>
&nbsp;            // Account for db
<b class="nc">&nbsp;            ratiob += -db * na / da / da;</b>
&nbsp;
<b class="nc">&nbsp;            result = ratioa + ratiob;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            double[] hiPrec = new double[2];</b>
&nbsp;            // tanh(x) = expm1(2x) / (expm1(2x) + 2)
<b class="nc">&nbsp;            expm1(x * 2.0, hiPrec);</b>
&nbsp;
<b class="nc">&nbsp;            double ya = hiPrec[0] + hiPrec[1];</b>
<b class="nc">&nbsp;            double yb = -(ya - hiPrec[0] - hiPrec[1]);</b>
&nbsp;
&nbsp;            /* Numerator */
<b class="nc">&nbsp;            double na = ya;</b>
<b class="nc">&nbsp;            double nb = yb;</b>
&nbsp;
&nbsp;            /* Denominator */
<b class="nc">&nbsp;            double da = 2.0 + ya;</b>
<b class="nc">&nbsp;            double db = -(da - 2.0 - ya);</b>
<b class="nc">&nbsp;            double temp = da + yb;</b>
<b class="nc">&nbsp;            db += -(temp - da - yb);</b>
<b class="nc">&nbsp;            da = temp;</b>
&nbsp;
<b class="nc">&nbsp;            temp = da * HEX_40000000;</b>
<b class="nc">&nbsp;            double daa = da + temp - temp;</b>
<b class="nc">&nbsp;            double dab = da - daa;</b>
&nbsp;
&nbsp;            // ratio = na/da
<b class="nc">&nbsp;            double ratio = na / da;</b>
<b class="nc">&nbsp;            temp = ratio * HEX_40000000;</b>
<b class="nc">&nbsp;            double ratioa = ratio + temp - temp;</b>
<b class="nc">&nbsp;            double ratiob = ratio - ratioa;</b>
&nbsp;
&nbsp;            // Correct for rounding in division
<b class="nc">&nbsp;            ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;</b>
&nbsp;
&nbsp;            // Account for nb
<b class="nc">&nbsp;            ratiob += nb / da;</b>
&nbsp;            // Account for db
<b class="nc">&nbsp;            ratiob += -db * na / da / da;</b>
&nbsp;
<b class="nc">&nbsp;            result = ratioa + ratiob;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (negate) {</b>
<b class="nc">&nbsp;            result = -result;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the inverse hyperbolic cosine of a number.
&nbsp;     * @param a number on which evaluation is done
&nbsp;     * @return inverse hyperbolic cosine of a
&nbsp;     */
&nbsp;    public static double acosh(final double a) {
<b class="nc">&nbsp;        return AccurateMath.log(a + AccurateMath.sqrt(a * a - 1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the inverse hyperbolic sine of a number.
&nbsp;     * @param a number on which evaluation is done
&nbsp;     * @return inverse hyperbolic sine of a
&nbsp;     */
&nbsp;    public static double asinh(double a) {
<b class="nc">&nbsp;        boolean negative = false;</b>
<b class="nc">&nbsp;        if (a &lt; 0) {</b>
<b class="nc">&nbsp;            negative = true;</b>
<b class="nc">&nbsp;            a = -a;</b>
&nbsp;        }
&nbsp;
&nbsp;        double absAsinh;
<b class="nc">&nbsp;        if (a &gt; 0.167) {</b>
<b class="nc">&nbsp;            absAsinh = AccurateMath.log(AccurateMath.sqrt(a * a + 1) + a);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            final double a2 = a * a;</b>
<b class="nc">&nbsp;            if (a &gt; 0.097) {</b>
<b class="nc">&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);</b>
<b class="nc">&nbsp;            } else if (a &gt; 0.036) {</b>
<b class="nc">&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);</b>
<b class="nc">&nbsp;            } else if (a &gt; 0.0036) {</b>
<b class="nc">&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return negative ? -absAsinh : absAsinh;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the inverse hyperbolic tangent of a number.
&nbsp;     * @param a number on which evaluation is done
&nbsp;     * @return inverse hyperbolic tangent of a
&nbsp;     */
&nbsp;    public static double atanh(double a) {
<b class="nc">&nbsp;        boolean negative = false;</b>
<b class="nc">&nbsp;        if (a &lt; 0) {</b>
<b class="nc">&nbsp;            negative = true;</b>
<b class="nc">&nbsp;            a = -a;</b>
&nbsp;        }
&nbsp;
&nbsp;        double absAtanh;
<b class="nc">&nbsp;        if (a &gt; 0.15) {</b>
<b class="nc">&nbsp;            absAtanh = 0.5 * AccurateMath.log((1 + a) / (1 - a));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            final double a2 = a * a;</b>
<b class="nc">&nbsp;            if (a &gt; 0.087) {</b>
<b class="nc">&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));</b>
<b class="nc">&nbsp;            } else if (a &gt; 0.031) {</b>
<b class="nc">&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));</b>
<b class="nc">&nbsp;            } else if (a &gt; 0.003) {</b>
<b class="nc">&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return negative ? -absAtanh : absAtanh;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the signum of a number.
&nbsp;     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
&nbsp;     * @param a number on which evaluation is done
&nbsp;     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
&nbsp;     */
&nbsp;    public static double signum(final double a) {
<b class="nc">&nbsp;        return (a &lt; 0.0) ? -1.0 : ((a &gt; 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the signum of a number.
&nbsp;     * The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise
&nbsp;     * @param a number on which evaluation is done
&nbsp;     * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a
&nbsp;     */
&nbsp;    public static float signum(final float a) {
<b class="nc">&nbsp;        return (a &lt; 0.0f) ? -1.0f : ((a &gt; 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute next number towards positive infinity.
&nbsp;     * @param a number to which neighbor should be computed
&nbsp;     * @return neighbor of a towards positive infinity
&nbsp;     */
&nbsp;    public static double nextUp(final double a) {
<b class="nc">&nbsp;        return nextAfter(a, Double.POSITIVE_INFINITY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute next number towards positive infinity.
&nbsp;     * @param a number to which neighbor should be computed
&nbsp;     * @return neighbor of a towards positive infinity
&nbsp;     */
&nbsp;    public static float nextUp(final float a) {
<b class="nc">&nbsp;        return nextAfter(a, Float.POSITIVE_INFINITY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute next number towards negative infinity.
&nbsp;     * @param a number to which neighbor should be computed
&nbsp;     * @return neighbor of a towards negative infinity
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static double nextDown(final double a) {
<b class="nc">&nbsp;        return nextAfter(a, Double.NEGATIVE_INFINITY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute next number towards negative infinity.
&nbsp;     * @param a number to which neighbor should be computed
&nbsp;     * @return neighbor of a towards negative infinity
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static float nextDown(final float a) {
<b class="nc">&nbsp;        return nextAfter(a, Float.NEGATIVE_INFINITY);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Returns a pseudo-random number between 0.0 and 1.0.
&nbsp;     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; this implementation currently delegates to {@link Math#random}
&nbsp;     * @return a random number between 0.0 and 1.0
&nbsp;     */
&nbsp;    public static double random() {
<b class="nc">&nbsp;        return Math.random();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exponential function.
&nbsp;     *
&nbsp;     * Computes exp(x), function result is nearly rounded.   It will be correctly
&nbsp;     * rounded to the theoretical value for 99.9% of input values, otherwise it will
&nbsp;     * have a 1 ULP error.
&nbsp;     *
&nbsp;     * Method:
&nbsp;     *    Lookup intVal = exp(int(x))
&nbsp;     *    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );
&nbsp;     *    Compute z as the exponential of the remaining bits by a polynomial minus one
&nbsp;     *    exp(x) = intVal * fracVal * (1 + z)
&nbsp;     *
&nbsp;     * Accuracy:
&nbsp;     *    Calculation is done with 63 bits of precision, so result should be correctly
&nbsp;     *    rounded for 99.9% of input values, with less than 1 ULP error otherwise.
&nbsp;     *
&nbsp;     * @param x   a double
&nbsp;     * @return double e&lt;sup&gt;x&lt;/sup&gt;
&nbsp;     */
&nbsp;    public static double exp(double x) {
<b class="nc">&nbsp;        return exp(x, 0.0, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Internal helper method for exponential function.
&nbsp;     * @param x original argument of the exponential function
&nbsp;     * @param extra extra bits of precision on input (To Be Confirmed)
&nbsp;     * @param hiPrec extra bits of precision on output (To Be Confirmed)
&nbsp;     * @return exp(x)
&nbsp;     */
&nbsp;    private static double exp(double x, double extra, double[] hiPrec) {
&nbsp;        double intPartA;
&nbsp;        double intPartB;
<b class="nc">&nbsp;        int intVal = (int) x;</b>
&nbsp;
&nbsp;        /* Lookup exp(floor(x)).
&nbsp;         * intPartA will have the upper 22 bits, intPartB will have the lower
&nbsp;         * 52 bits.
&nbsp;         */
<b class="nc">&nbsp;        if (x &lt; 0.0) {</b>
&nbsp;
&nbsp;            // We don&#39;t check against intVal here as conversion of large negative double values
&nbsp;            // may be affected by a JIT bug. Subsequent comparisons can safely use intVal
<b class="nc">&nbsp;            if (x &lt; -746d) {</b>
<b class="nc">&nbsp;                if (hiPrec != null) {</b>
<b class="nc">&nbsp;                    hiPrec[0] = 0.0;</b>
<b class="nc">&nbsp;                    hiPrec[1] = 0.0;</b>
&nbsp;                }
<b class="nc">&nbsp;                return 0.0;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (intVal &lt; -709) {</b>
&nbsp;                /* This will produce a subnormal output */
<b class="nc">&nbsp;                final double result = exp(x + 40.19140625, extra, hiPrec) / 285040095144011776.0;</b>
<b class="nc">&nbsp;                if (hiPrec != null) {</b>
<b class="nc">&nbsp;                    hiPrec[0] /= 285040095144011776.0;</b>
<b class="nc">&nbsp;                    hiPrec[1] /= 285040095144011776.0;</b>
&nbsp;                }
<b class="nc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (intVal == -709) {</b>
&nbsp;                /* exp(1.494140625) is nearly a machine number... */
<b class="nc">&nbsp;                final double result = exp(x + 1.494140625, extra, hiPrec) / 4.455505956692756620;</b>
<b class="nc">&nbsp;                if (hiPrec != null) {</b>
<b class="nc">&nbsp;                    hiPrec[0] /= 4.455505956692756620;</b>
<b class="nc">&nbsp;                    hiPrec[1] /= 4.455505956692756620;</b>
&nbsp;                }
<b class="nc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            intVal--;</b>
&nbsp;
&nbsp;        } else {
<b class="nc">&nbsp;            if (intVal &gt; 709) {</b>
<b class="nc">&nbsp;                if (hiPrec != null) {</b>
<b class="nc">&nbsp;                    hiPrec[0] = Double.POSITIVE_INFINITY;</b>
<b class="nc">&nbsp;                    hiPrec[1] = 0.0;</b>
&nbsp;                }
<b class="nc">&nbsp;                return Double.POSITIVE_INFINITY;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];</b>
<b class="nc">&nbsp;        intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];</b>
&nbsp;
&nbsp;        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than
&nbsp;         * x and look up the exp function of it.
&nbsp;         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.
&nbsp;         */
<b class="nc">&nbsp;        final int intFrac = (int) ((x - intVal) * 1024.0);</b>
<b class="nc">&nbsp;        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];</b>
<b class="nc">&nbsp;        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];</b>
&nbsp;
&nbsp;        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It
&nbsp;         * has a value in the range 0 &lt;= epsilon &lt; 2^-10.
&nbsp;         * Do the subtraction from x as the last step to avoid possible loss of precision.
&nbsp;         */
<b class="nc">&nbsp;        final double epsilon = x - (intVal + intFrac / 1024.0);</b>
&nbsp;
&nbsp;        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has
&nbsp;       full double precision (52 bits).  Since z &lt; 2^-10, we will have
&nbsp;       62 bits of precision when combined with the constant 1.  This will be
&nbsp;       used in the last addition below to get proper rounding. */
&nbsp;
&nbsp;        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error
&nbsp;       is less than 0.5 ULP */
<b class="nc">&nbsp;        double z = 0.04168701738764507;</b>
<b class="nc">&nbsp;        z = z * epsilon + 0.1666666505023083;</b>
<b class="nc">&nbsp;        z = z * epsilon + 0.5000000000042687;</b>
<b class="nc">&nbsp;        z = z * epsilon + 1.0;</b>
<b class="nc">&nbsp;        z = z * epsilon + -3.940510424527919E-20;</b>
&nbsp;
&nbsp;        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial
&nbsp;       expansion.
&nbsp;       tempA is exact since intPartA and intPartB only have 22 bits each.
&nbsp;       tempB will have 52 bits of precision.
&nbsp;         */
<b class="nc">&nbsp;        double tempA = intPartA * fracPartA;</b>
<b class="nc">&nbsp;        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;</b>
&nbsp;
&nbsp;        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is
&nbsp;       important.  For accuracy add by increasing size.  tempA is exact and
&nbsp;       much larger than the others.  If there are extra bits specified from the
&nbsp;       pow() function, use them. */
<b class="nc">&nbsp;        final double tempC = tempB + tempA;</b>
&nbsp;
&nbsp;        // If tempC is positive infinite, the evaluation below could result in NaN,
&nbsp;        // because z could be negative at the same time.
<b class="nc">&nbsp;        if (tempC == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return Double.POSITIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
&nbsp;        final double result;
<b class="nc">&nbsp;        if (extra != 0.0) {</b>
<b class="nc">&nbsp;            result = tempC * extra * z + tempC * extra + tempC * z + tempB + tempA;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            result = tempC * z + tempB + tempA;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hiPrec != null) {</b>
&nbsp;            // If requesting high precision
<b class="nc">&nbsp;            hiPrec[0] = tempA;</b>
<b class="nc">&nbsp;            hiPrec[1] = tempC * extra * z + tempC * extra + tempC * z + tempB;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**Compute exp(x) - 1.
&nbsp;     *
&nbsp;     * @param x number to compute shifted exponential
&nbsp;     * @return exp(x) - 1
&nbsp;     */
&nbsp;    public static double expm1(double x) {
<b class="nc">&nbsp;        return expm1(x, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Internal helper method for expm1.
&nbsp;     * @param x number to compute shifted exponential
&nbsp;     * @param hiPrecOut receive high precision result for -1.0 &lt; x &lt; 1.0
&nbsp;     * @return exp(x) - 1
&nbsp;     */
&nbsp;    private static double expm1(double x, double[] hiPrecOut) {
<b class="nc">&nbsp;        if (Double.isNaN(x) || x == 0.0) { // NaN or zero</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &lt;= -1.0 || x &gt;= 1.0) {</b>
&nbsp;            // If not between +/- 1.0
&nbsp;            //return exp(x) - 1.0;
<b class="nc">&nbsp;            double[] hiPrec = new double[2];</b>
<b class="nc">&nbsp;            exp(x, 0.0, hiPrec);</b>
<b class="nc">&nbsp;            if (x &gt; 0.0) {</b>
<b class="nc">&nbsp;                return -1.0 + hiPrec[0] + hiPrec[1];</b>
&nbsp;            } else {
<b class="nc">&nbsp;                final double ra = -1.0 + hiPrec[0];</b>
<b class="nc">&nbsp;                double rb = -(ra + 1.0 - hiPrec[0]);</b>
<b class="nc">&nbsp;                rb += hiPrec[1];</b>
<b class="nc">&nbsp;                return ra + rb;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        double baseA;
&nbsp;        double baseB;
&nbsp;        double epsilon;
<b class="nc">&nbsp;        boolean negative = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (x &lt; 0.0) {</b>
<b class="nc">&nbsp;            x = -x;</b>
<b class="nc">&nbsp;            negative = true;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        int intFrac = (int) (x * 1024.0);</b>
<b class="nc">&nbsp;        double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;</b>
<b class="nc">&nbsp;        double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];</b>
&nbsp;
<b class="nc">&nbsp;        double temp = tempA + tempB;</b>
<b class="nc">&nbsp;        tempB = -(temp - tempA - tempB);</b>
<b class="nc">&nbsp;        tempA = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = tempA * HEX_40000000;</b>
<b class="nc">&nbsp;        baseA = tempA + temp - temp;</b>
<b class="nc">&nbsp;        baseB = tempB + (tempA - baseA);</b>
&nbsp;
<b class="nc">&nbsp;        epsilon = x - intFrac / 1024.0;</b>
&nbsp;
&nbsp;
&nbsp;        /* Compute expm1(epsilon) */
<b class="nc">&nbsp;        double zb = 0.008336750013465571;</b>
<b class="nc">&nbsp;        zb = zb * epsilon + 0.041666663879186654;</b>
<b class="nc">&nbsp;        zb = zb * epsilon + 0.16666666666745392;</b>
<b class="nc">&nbsp;        zb = zb * epsilon + 0.49999999999999994;</b>
<b class="nc">&nbsp;        zb *= epsilon;</b>
<b class="nc">&nbsp;        zb *= epsilon;</b>
&nbsp;
<b class="nc">&nbsp;        double za = epsilon;</b>
<b class="nc">&nbsp;        temp = za + zb;</b>
<b class="nc">&nbsp;        zb = -(temp - za - zb);</b>
<b class="nc">&nbsp;        za = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = za * HEX_40000000;</b>
<b class="nc">&nbsp;        temp = za + temp - temp;</b>
<b class="nc">&nbsp;        zb += za - temp;</b>
<b class="nc">&nbsp;        za = temp;</b>
&nbsp;
&nbsp;        /* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */
<b class="nc">&nbsp;        double ya = za * baseA;</b>
&nbsp;        //double yb = za*baseB + zb*baseA + zb*baseB;
<b class="nc">&nbsp;        temp = ya + za * baseB;</b>
<b class="nc">&nbsp;        double yb = -(temp - ya - za * baseB);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = ya + zb * baseA;</b>
<b class="nc">&nbsp;        yb += -(temp - ya - zb * baseA);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = ya + zb * baseB;</b>
<b class="nc">&nbsp;        yb += -(temp - ya - zb * baseB);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
&nbsp;        //ya = ya + za + baseA;
&nbsp;        //yb = yb + zb + baseB;
<b class="nc">&nbsp;        temp = ya + baseA;</b>
<b class="nc">&nbsp;        yb += -(temp - baseA - ya);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = ya + za;</b>
&nbsp;        //yb += (ya &gt; za) ? -(temp - ya - za) : -(temp - za - ya);
<b class="nc">&nbsp;        yb += -(temp - ya - za);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = ya + baseB;</b>
&nbsp;        //yb += (ya &gt; baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);
<b class="nc">&nbsp;        yb += -(temp - ya - baseB);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        temp = ya + zb;</b>
&nbsp;        //yb += (ya &gt; zb) ? -(temp - ya - zb) : -(temp - zb - ya);
<b class="nc">&nbsp;        yb += -(temp - ya - zb);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
<b class="nc">&nbsp;        if (negative) {</b>
&nbsp;            /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
<b class="nc">&nbsp;            double denom = 1.0 + ya;</b>
<b class="nc">&nbsp;            double denomr = 1.0 / denom;</b>
<b class="nc">&nbsp;            double denomb = -(denom - 1.0 - ya) + yb;</b>
<b class="nc">&nbsp;            double ratio = ya * denomr;</b>
<b class="nc">&nbsp;            temp = ratio * HEX_40000000;</b>
<b class="nc">&nbsp;            final double ra = ratio + temp - temp;</b>
<b class="nc">&nbsp;            double rb = ratio - ra;</b>
&nbsp;
<b class="nc">&nbsp;            temp = denom * HEX_40000000;</b>
<b class="nc">&nbsp;            za = denom + temp - temp;</b>
<b class="nc">&nbsp;            zb = denom - za;</b>
&nbsp;
<b class="nc">&nbsp;            rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;</b>
&nbsp;
&nbsp;            // f(x) = x/1+x
&nbsp;            // Compute f&#39;(x)
&nbsp;            // Product rule:  d(uv) = du*v + u*dv
&nbsp;            // Chain rule:  d(f(g(x)) = f&#39;(g(x))*f(g&#39;(x))
&nbsp;            // d(1/x) = -1/(x*x)
&nbsp;            // d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))
&nbsp;            // d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))
&nbsp;
&nbsp;            // Adjust for yb
<b class="nc">&nbsp;            rb += yb * denomr;                      // numerator</b>
<b class="nc">&nbsp;            rb += -ya * denomb * denomr * denomr;   // denominator</b>
&nbsp;
&nbsp;            // negate
<b class="nc">&nbsp;            ya = -ra;</b>
<b class="nc">&nbsp;            yb = -rb;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (hiPrecOut != null) {</b>
<b class="nc">&nbsp;            hiPrecOut[0] = ya;</b>
<b class="nc">&nbsp;            hiPrecOut[1] = yb;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return ya + yb;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Natural logarithm.
&nbsp;     *
&nbsp;     * @param x   a double
&nbsp;     * @return log(x)
&nbsp;     */
&nbsp;    public static double log(final double x) {
<b class="nc">&nbsp;        return log(x, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Internal helper method for natural logarithm function.
&nbsp;     * @param x original argument of the natural logarithm function
&nbsp;     * @param hiPrec extra bits of precision on output (To Be Confirmed)
&nbsp;     * @return log(x)
&nbsp;     */
&nbsp;    private static double log(final double x, final double[] hiPrec) {
<b class="nc">&nbsp;        if (x == 0) { // Handle special case of +0/-0</b>
<b class="nc">&nbsp;            return Double.NEGATIVE_INFINITY;</b>
&nbsp;        }
<b class="nc">&nbsp;        long bits = Double.doubleToRawLongBits(x);</b>
&nbsp;
&nbsp;        /* Handle special cases of negative input, and NaN */
<b class="nc">&nbsp;        if (((bits &amp; 0x8000000000000000L) != 0 || Double.isNaN(x)) &amp;&amp; x != 0.0) {</b>
<b class="nc">&nbsp;            if (hiPrec != null) {</b>
<b class="nc">&nbsp;                hiPrec[0] = Double.NaN;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Handle special cases of Positive infinity. */
<b class="nc">&nbsp;        if (x == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            if (hiPrec != null) {</b>
<b class="nc">&nbsp;                hiPrec[0] = Double.POSITIVE_INFINITY;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return Double.POSITIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Extract the exponent */
<b class="nc">&nbsp;        int exp = (int) (bits &gt;&gt; 52) - 1023;</b>
&nbsp;
<b class="nc">&nbsp;        if ((bits &amp; 0x7ff0000000000000L) == 0) {</b>
&nbsp;            // Subnormal!
<b class="nc">&nbsp;            if (x == 0) {</b>
&nbsp;                // Zero
<b class="nc">&nbsp;                if (hiPrec != null) {</b>
<b class="nc">&nbsp;                    hiPrec[0] = Double.NEGATIVE_INFINITY;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                return Double.NEGATIVE_INFINITY;</b>
&nbsp;            }
&nbsp;
&nbsp;            /* Normalize the subnormal number. */
<b class="nc">&nbsp;            bits &lt;&lt;= 1;</b>
<b class="nc">&nbsp;            while ((bits &amp; 0x0010000000000000L) == 0) {</b>
<b class="nc">&nbsp;                --exp;</b>
<b class="nc">&nbsp;                bits &lt;&lt;= 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        if ((exp == -1 || exp == 0) &amp;&amp; x &lt; 1.01 &amp;&amp; x &gt; 0.99 &amp;&amp; hiPrec == null) {</b>
&nbsp;            /* The normal method doesn&#39;t work well in the range [0.99, 1.01], so call do a straight
&nbsp;           polynomial expansion in higer precision. */
&nbsp;
&nbsp;            /* Compute x - 1.0 and split it */
<b class="nc">&nbsp;            double xa = x - 1.0;</b>
<b class="nc">&nbsp;            double xb = xa - x + 1.0;</b>
<b class="nc">&nbsp;            double tmp = xa * HEX_40000000;</b>
<b class="nc">&nbsp;            double aa = xa + tmp - tmp;</b>
<b class="nc">&nbsp;            double ab = xa - aa;</b>
<b class="nc">&nbsp;            xa = aa;</b>
<b class="nc">&nbsp;            xb = ab;</b>
&nbsp;
<b class="nc">&nbsp;            final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];</b>
<b class="nc">&nbsp;            double ya = lnCoef_last[0];</b>
<b class="nc">&nbsp;            double yb = lnCoef_last[1];</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = LN_QUICK_COEF.length - 2; i &gt;= 0; i--) {</b>
&nbsp;                /* Multiply a = y * x */
<b class="nc">&nbsp;                aa = ya * xa;</b>
<b class="nc">&nbsp;                ab = ya * xb + yb * xa + yb * xb;</b>
&nbsp;                /* split, so now y = a */
<b class="nc">&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="nc">&nbsp;                ya = aa + tmp - tmp;</b>
<b class="nc">&nbsp;                yb = aa - ya + ab;</b>
&nbsp;
&nbsp;                /* Add  a = y + lnQuickCoef */
<b class="nc">&nbsp;                final double[] lnCoef_i = LN_QUICK_COEF[i];</b>
<b class="nc">&nbsp;                aa = ya + lnCoef_i[0];</b>
<b class="nc">&nbsp;                ab = yb + lnCoef_i[1];</b>
&nbsp;                /* Split y = a */
<b class="nc">&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="nc">&nbsp;                ya = aa + tmp - tmp;</b>
<b class="nc">&nbsp;                yb = aa - ya + ab;</b>
&nbsp;            }
&nbsp;
&nbsp;            /* Multiply a = y * x */
<b class="nc">&nbsp;            aa = ya * xa;</b>
<b class="nc">&nbsp;            ab = ya * xb + yb * xa + yb * xb;</b>
&nbsp;            /* split, so now y = a */
<b class="nc">&nbsp;            tmp = aa * HEX_40000000;</b>
<b class="nc">&nbsp;            ya = aa + tmp - tmp;</b>
<b class="nc">&nbsp;            yb = aa - ya + ab;</b>
&nbsp;
<b class="nc">&nbsp;            return ya + yb;</b>
&nbsp;        }
&nbsp;
&nbsp;        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 &lt;= lnm &lt; ln(2)
<b class="nc">&nbsp;        final double[] lnm = lnMant.LN_MANT[(int)((bits &amp; 0x000ffc0000000000L) &gt;&gt; 42)];</b>
&nbsp;
&nbsp;        /*
&nbsp;    double epsilon = x / Double.longBitsToDouble(bits &amp; 0xfffffc0000000000L);
&nbsp;
&nbsp;    epsilon -= 1.0;
&nbsp;         */
&nbsp;
&nbsp;        // y is the most significant 10 bits of the mantissa
&nbsp;        //double y = Double.longBitsToDouble(bits &amp; 0xfffffc0000000000L);
&nbsp;        //double epsilon = (x - y) / y;
<b class="nc">&nbsp;        final double epsilon = (bits &amp; 0x3ffffffffffL) / (TWO_POWER_52 + (bits &amp; 0x000ffc0000000000L));</b>
&nbsp;
<b class="nc">&nbsp;        double lnza = 0.0;</b>
<b class="nc">&nbsp;        double lnzb = 0.0;</b>
&nbsp;
<b class="nc">&nbsp;        if (hiPrec != null) {</b>
&nbsp;            /* split epsilon -&gt; x */
<b class="nc">&nbsp;            double tmp = epsilon * HEX_40000000;</b>
<b class="nc">&nbsp;            double aa = epsilon + tmp - tmp;</b>
<b class="nc">&nbsp;            double ab = epsilon - aa;</b>
<b class="nc">&nbsp;            double xa = aa;</b>
<b class="nc">&nbsp;            double xb = ab;</b>
&nbsp;
&nbsp;            /* Need a more accurate epsilon, so adjust the division. */
<b class="nc">&nbsp;            final double numer = bits &amp; 0x3ffffffffffL;</b>
<b class="nc">&nbsp;            final double denom = TWO_POWER_52 + (bits &amp; 0x000ffc0000000000L);</b>
<b class="nc">&nbsp;            aa = numer - xa * denom - xb * denom;</b>
<b class="nc">&nbsp;            xb += aa / denom;</b>
&nbsp;
&nbsp;            /* Remez polynomial evaluation */
<b class="nc">&nbsp;            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1];</b>
<b class="nc">&nbsp;            double ya = lnCoef_last[0];</b>
<b class="nc">&nbsp;            double yb = lnCoef_last[1];</b>
&nbsp;
<b class="nc">&nbsp;            for (int i = LN_HI_PREC_COEF.length - 2; i &gt;= 0; i--) {</b>
&nbsp;                /* Multiply a = y * x */
<b class="nc">&nbsp;                aa = ya * xa;</b>
<b class="nc">&nbsp;                ab = ya * xb + yb * xa + yb * xb;</b>
&nbsp;                /* split, so now y = a */
<b class="nc">&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="nc">&nbsp;                ya = aa + tmp - tmp;</b>
<b class="nc">&nbsp;                yb = aa - ya + ab;</b>
&nbsp;
&nbsp;                /* Add  a = y + lnHiPrecCoef */
<b class="nc">&nbsp;                final double[] lnCoef_i = LN_HI_PREC_COEF[i];</b>
<b class="nc">&nbsp;                aa = ya + lnCoef_i[0];</b>
<b class="nc">&nbsp;                ab = yb + lnCoef_i[1];</b>
&nbsp;                /* Split y = a */
<b class="nc">&nbsp;                tmp = aa * HEX_40000000;</b>
<b class="nc">&nbsp;                ya = aa + tmp - tmp;</b>
<b class="nc">&nbsp;                yb = aa - ya + ab;</b>
&nbsp;            }
&nbsp;
&nbsp;            /* Multiply a = y * x */
<b class="nc">&nbsp;            aa = ya * xa;</b>
<b class="nc">&nbsp;            ab = ya * xb + yb * xa + yb * xb;</b>
&nbsp;
&nbsp;            /* split, so now lnz = a */
&nbsp;            /*
&nbsp;      tmp = aa * 1073741824.0;
&nbsp;      lnza = aa + tmp - tmp;
&nbsp;      lnzb = aa - lnza + ab;
&nbsp;             */
<b class="nc">&nbsp;            lnza = aa + ab;</b>
<b class="nc">&nbsp;            lnzb = -(lnza - aa - ab);</b>
<b class="nc">&nbsp;        } else {</b>
&nbsp;            /* High precision not required.  Eval Remez polynomial
&nbsp;         using standard double precision */
<b class="nc">&nbsp;            lnza = -0.16624882440418567;</b>
<b class="nc">&nbsp;            lnza = lnza * epsilon + 0.19999954120254515;</b>
<b class="nc">&nbsp;            lnza = lnza * epsilon + -0.2499999997677497;</b>
<b class="nc">&nbsp;            lnza = lnza * epsilon + 0.3333333333332802;</b>
<b class="nc">&nbsp;            lnza = lnza * epsilon + -0.5;</b>
<b class="nc">&nbsp;            lnza = lnza * epsilon + 1.0;</b>
<b class="nc">&nbsp;            lnza *= epsilon;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Relative sizes:
&nbsp;         * lnzb     [0, 2.33E-10]
&nbsp;         * lnm[1]   [0, 1.17E-7]
&nbsp;         * ln2B*exp [0, 1.12E-4]
&nbsp;         * lnza      [0, 9.7E-4]
&nbsp;         * lnm[0]   [0, 0.692]
&nbsp;         * ln2A*exp [0, 709]
&nbsp;         */
&nbsp;
&nbsp;        /* Compute the following sum:
&nbsp;         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
&nbsp;         */
&nbsp;
&nbsp;        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;
<b class="nc">&nbsp;        double a = LN_2_A * exp;</b>
<b class="nc">&nbsp;        double b = 0.0;</b>
<b class="nc">&nbsp;        double c = a + lnm[0];</b>
<b class="nc">&nbsp;        double d = -(c - a - lnm[0]);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        c = a + lnza;</b>
<b class="nc">&nbsp;        d = -(c - a - lnza);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        c = a + LN_2_B * exp;</b>
<b class="nc">&nbsp;        d = -(c - a - LN_2_B * exp);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        c = a + lnm[1];</b>
<b class="nc">&nbsp;        d = -(c - a - lnm[1]);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        c = a + lnzb;</b>
<b class="nc">&nbsp;        d = -(c - a - lnzb);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        if (hiPrec != null) {</b>
<b class="nc">&nbsp;            hiPrec[0] = a;</b>
<b class="nc">&nbsp;            hiPrec[1] = b;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return a + b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes log(1 + x).
&nbsp;     *
&nbsp;     * @param x Number.
&nbsp;     * @return {@code log(1 + x)}.
&nbsp;     */
&nbsp;    public static double log1p(final double x) {
<b class="nc">&nbsp;        if (x == -1) {</b>
<b class="nc">&nbsp;            return Double.NEGATIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return Double.POSITIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 1e-6 ||</b>
&nbsp;            x &lt; -1e-6) {
<b class="nc">&nbsp;            final double xpa = 1 + x;</b>
<b class="nc">&nbsp;            final double xpb = -(xpa - 1 - x);</b>
&nbsp;
<b class="nc">&nbsp;            final double[] hiPrec = new double[2];</b>
<b class="nc">&nbsp;            final double lores = log(xpa, hiPrec);</b>
<b class="nc">&nbsp;            if (Double.isInfinite(lores)) { // Don&#39;t allow this to be converted to NaN</b>
<b class="nc">&nbsp;                return lores;</b>
&nbsp;            }
&nbsp;
&nbsp;            // Do a taylor series expansion around xpa:
&nbsp;            //   f(x+y) = f(x) + f&#39;(x) y + f&#39;&#39;(x)/2 y^2
<b class="nc">&nbsp;            final double fx1 = xpb / xpa;</b>
<b class="nc">&nbsp;            final double epsilon = 0.5 * fx1 + 1;</b>
<b class="nc">&nbsp;            return epsilon * fx1 + hiPrec[1] + hiPrec[0];</b>
&nbsp;        } else {
&nbsp;            // Value is small |x| &lt; 1e6, do a Taylor series centered on 1.
<b class="nc">&nbsp;            final double y = (x * F_1_3 - F_1_2) * x + 1;</b>
<b class="nc">&nbsp;            return y * x;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the base 10 logarithm.
&nbsp;     * @param x a number
&nbsp;     * @return log10(x)
&nbsp;     */
&nbsp;    public static double log10(final double x) {
<b class="nc">&nbsp;        final double[] hiPrec = new double[2];</b>
&nbsp;
<b class="nc">&nbsp;        final double lores = log(x, hiPrec);</b>
<b class="nc">&nbsp;        if (Double.isInfinite(lores)) { // don&#39;t allow this to be converted to NaN</b>
<b class="nc">&nbsp;            return lores;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final double tmp = hiPrec[0] * HEX_40000000;</b>
<b class="nc">&nbsp;        final double lna = hiPrec[0] + tmp - tmp;</b>
<b class="nc">&nbsp;        final double lnb = hiPrec[0] - lna + hiPrec[1];</b>
&nbsp;
<b class="nc">&nbsp;        final double rln10a = 0.4342944622039795;</b>
<b class="nc">&nbsp;        final double rln10b = 1.9699272335463627E-8;</b>
&nbsp;
<b class="nc">&nbsp;        return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes the &lt;a href=&quot;http://mathworld.wolfram.com/Logarithm.html&quot;&gt;
&nbsp;     * logarithm&lt;/a&gt; in a given base.
&nbsp;     *
&nbsp;     * Returns {@code NaN} if either argument is negative.
&nbsp;     * If {@code base} is 0 and {@code x} is positive, 0 is returned.
&nbsp;     * If {@code base} is positive and {@code x} is 0,
&nbsp;     * {@code Double.NEGATIVE_INFINITY} is returned.
&nbsp;     * If both arguments are 0, the result is {@code NaN}.
&nbsp;     *
&nbsp;     * @param base Base of the logarithm, must be greater than 0.
&nbsp;     * @param x Argument, must be greater than 0.
&nbsp;     * @return the value of the logarithm, i.e. the number {@code y} such that
&nbsp;     * &lt;code&gt;base&lt;sup&gt;y&lt;/sup&gt; = x&lt;/code&gt;.
&nbsp;     * @since 3.0
&nbsp;     */
&nbsp;    public static double log(double base, double x) {
<b class="nc">&nbsp;        return log(x) / log(base);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Power function.  Compute x^y.
&nbsp;     *
&nbsp;     * @param x   a double
&nbsp;     * @param y   a double
&nbsp;     * @return double
&nbsp;     */
&nbsp;    public static double pow(final double x, final double y) {
&nbsp;
<b class="nc">&nbsp;        if (y == 0) {</b>
&nbsp;            // y = -0 or y = +0
<b class="nc">&nbsp;            return 1.0;</b>
&nbsp;        } else {
&nbsp;
<b class="nc">&nbsp;            final long yBits        = Double.doubleToRawLongBits(y);</b>
<b class="nc">&nbsp;            final int  yRawExp      = (int) ((yBits &amp; MASK_DOUBLE_EXPONENT) &gt;&gt; 52);</b>
<b class="nc">&nbsp;            final long yRawMantissa = yBits &amp; MASK_DOUBLE_MANTISSA;</b>
<b class="nc">&nbsp;            final long xBits        = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;            final int  xRawExp      = (int) ((xBits &amp; MASK_DOUBLE_EXPONENT) &gt;&gt; 52);</b>
<b class="nc">&nbsp;            final long xRawMantissa = xBits &amp; MASK_DOUBLE_MANTISSA;</b>
&nbsp;
<b class="nc">&nbsp;            if (yRawExp &gt; 1085) {</b>
&nbsp;                // y is either a very large integral value that does not fit in a long or it is a special number
&nbsp;
<b class="nc">&nbsp;                if ((yRawExp == 2047 &amp;&amp; yRawMantissa != 0) ||</b>
&nbsp;                    (xRawExp == 2047 &amp;&amp; xRawMantissa != 0)) {
&nbsp;                    // NaN
<b class="nc">&nbsp;                    return Double.NaN;</b>
<b class="nc">&nbsp;                } else if (xRawExp == 1023 &amp;&amp; xRawMantissa == 0) {</b>
&nbsp;                    // x = -1.0 or x = +1.0
<b class="nc">&nbsp;                    if (yRawExp == 2047) {</b>
&nbsp;                        // y is infinite
<b class="nc">&nbsp;                        return Double.NaN;</b>
&nbsp;                    } else {
&nbsp;                        // y is a large even integer
<b class="nc">&nbsp;                        return 1.0;</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // the absolute value of x is either greater or smaller than 1.0
&nbsp;
&nbsp;                    // if yRawExp == 2047 and mantissa is 0, y = -infinity or y = +infinity
&nbsp;                    // if 1085 &lt; yRawExp &lt; 2047, y is simply a large number, however, due to limited
&nbsp;                    // accuracy, at this magnitude it behaves just like infinity with regards to x
<b class="nc">&nbsp;                    if ((y &gt; 0) ^ (xRawExp &lt; 1023)) {</b>
&nbsp;                        // either y = +infinity (or large engouh) and abs(x) &gt; 1.0
&nbsp;                        // or     y = -infinity (or large engouh) and abs(x) &lt; 1.0
<b class="nc">&nbsp;                        return Double.POSITIVE_INFINITY;</b>
&nbsp;                    } else {
&nbsp;                        // either y = +infinity (or large engouh) and abs(x) &lt; 1.0
&nbsp;                        // or     y = -infinity (or large engouh) and abs(x) &gt; 1.0
<b class="nc">&nbsp;                        return +0.0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;            } else {
&nbsp;                // y is a regular non-zero number
&nbsp;
<b class="nc">&nbsp;                if (yRawExp &gt;= 1023) {</b>
&nbsp;                    // y may be an integral value, which should be handled specifically
<b class="nc">&nbsp;                    final long yFullMantissa = IMPLICIT_HIGH_BIT | yRawMantissa;</b>
<b class="nc">&nbsp;                    if (yRawExp &lt; 1075) {</b>
&nbsp;                        // normal number with negative shift that may have a fractional part
<b class="nc">&nbsp;                        final long integralMask = (-1L) &lt;&lt; (1075 - yRawExp);</b>
<b class="nc">&nbsp;                        if ((yFullMantissa &amp; integralMask) == yFullMantissa) {</b>
&nbsp;                            // all fractional bits are 0, the number is really integral
<b class="nc">&nbsp;                            final long l = yFullMantissa &gt;&gt; (1075 - yRawExp);</b>
<b class="nc">&nbsp;                            return AccurateMath.pow(x, (y &lt; 0) ? -l : l);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } else {</b>
&nbsp;                        // normal number with positive shift, always an integral value
&nbsp;                        // we know it fits in a primitive long because yRawExp &gt; 1085 has been handled above
<b class="nc">&nbsp;                        final long l =  yFullMantissa &lt;&lt; (yRawExp - 1075);</b>
<b class="nc">&nbsp;                        return AccurateMath.pow(x, (y &lt; 0) ? -l : l);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                // y is a non-integral value
&nbsp;
<b class="nc">&nbsp;                if (x == 0) {</b>
&nbsp;                    // x = -0 or x = +0
&nbsp;                    // the integer powers have already been handled above
<b class="nc">&nbsp;                    return y &lt; 0 ? Double.POSITIVE_INFINITY : +0.0;</b>
<b class="nc">&nbsp;                } else if (xRawExp == 2047) {</b>
<b class="nc">&nbsp;                    if (xRawMantissa == 0) {</b>
&nbsp;                        // x = -infinity or x = +infinity
<b class="nc">&nbsp;                        return (y &lt; 0) ? +0.0 : Double.POSITIVE_INFINITY;</b>
&nbsp;                    } else {
&nbsp;                        // NaN
<b class="nc">&nbsp;                        return Double.NaN;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } else if (x &lt; 0) {</b>
&nbsp;                    // the integer powers have already been handled above
<b class="nc">&nbsp;                    return Double.NaN;</b>
&nbsp;                } else {
&nbsp;
&nbsp;                    // this is the general case, for regular fractional numbers x and y
&nbsp;
&nbsp;                    // Split y into ya and yb such that y = ya+yb
<b class="nc">&nbsp;                    final double tmp = y * HEX_40000000;</b>
<b class="nc">&nbsp;                    final double ya = (y + tmp) - tmp;</b>
<b class="nc">&nbsp;                    final double yb = y - ya;</b>
&nbsp;
&nbsp;                    /* Compute ln(x) */
<b class="nc">&nbsp;                    final double[] lns = new double[2];</b>
<b class="nc">&nbsp;                    final double lores = log(x, lns);</b>
<b class="nc">&nbsp;                    if (Double.isInfinite(lores)) { // don&#39;t allow this to be converted to NaN</b>
<b class="nc">&nbsp;                        return lores;</b>
&nbsp;                    }
&nbsp;
<b class="nc">&nbsp;                    double lna = lns[0];</b>
<b class="nc">&nbsp;                    double lnb = lns[1];</b>
&nbsp;
&nbsp;                    /* resplit lns */
<b class="nc">&nbsp;                    final double tmp1 = lna * HEX_40000000;</b>
<b class="nc">&nbsp;                    final double tmp2 = (lna + tmp1) - tmp1;</b>
<b class="nc">&nbsp;                    lnb += lna - tmp2;</b>
<b class="nc">&nbsp;                    lna = tmp2;</b>
&nbsp;
&nbsp;                    // y*ln(x) = (aa+ab)
<b class="nc">&nbsp;                    final double aa = lna * ya;</b>
<b class="nc">&nbsp;                    final double ab = lna * yb + lnb * ya + lnb * yb;</b>
&nbsp;
<b class="nc">&nbsp;                    lna = aa + ab;</b>
<b class="nc">&nbsp;                    lnb = -(lna - aa - ab);</b>
&nbsp;
<b class="nc">&nbsp;                    double z = 1.0 / 120.0;</b>
<b class="nc">&nbsp;                    z = z * lnb + (1.0 / 24.0);</b>
<b class="nc">&nbsp;                    z = z * lnb + (1.0 / 6.0);</b>
<b class="nc">&nbsp;                    z = z * lnb + 0.5;</b>
<b class="nc">&nbsp;                    z = z * lnb + 1.0;</b>
<b class="nc">&nbsp;                    z *= lnb;</b>
&nbsp;
<b class="nc">&nbsp;                    final double result = exp(lna, z, null);</b>
&nbsp;                    //result = result + result * z;
<b class="nc">&nbsp;                    return result;</b>
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Raise a double to an int power.
&nbsp;     *
&nbsp;     * @param d Number to raise.
&nbsp;     * @param e Exponent.
&nbsp;     * @return d&lt;sup&gt;e&lt;/sup&gt;
&nbsp;     * @since 3.1
&nbsp;     */
&nbsp;    public static double pow(double d, int e) {
<b class="nc">&nbsp;        return pow(d, (long) e);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Raise a double to a long power.
&nbsp;     *
&nbsp;     * @param d Number to raise.
&nbsp;     * @param e Exponent.
&nbsp;     * @return d&lt;sup&gt;e&lt;/sup&gt;
&nbsp;     * @since 3.6
&nbsp;     */
&nbsp;    public static double pow(double d, long e) {
<b class="nc">&nbsp;        if (e == 0) {</b>
<b class="nc">&nbsp;            return 1.0;</b>
<b class="nc">&nbsp;        } else if (e &gt; 0) {</b>
<b class="nc">&nbsp;            return new Split(d).pow(e).full;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return new Split(d).reciprocal().pow(-e).full;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Class operator on double numbers split into one 26 bits number and one 27 bits number. */
<b class="nc">&nbsp;    private static class Split {</b>
&nbsp;
&nbsp;        /** Split version of NaN. */
<b class="nc">&nbsp;        public static final Split NAN = new Split(Double.NaN, 0);</b>
&nbsp;
&nbsp;        /** Split version of positive infinity. */
<b class="nc">&nbsp;        public static final Split POSITIVE_INFINITY = new Split(Double.POSITIVE_INFINITY, 0);</b>
&nbsp;
&nbsp;        /** Split version of negative infinity. */
<b class="nc">&nbsp;        public static final Split NEGATIVE_INFINITY = new Split(Double.NEGATIVE_INFINITY, 0);</b>
&nbsp;
&nbsp;        /** Full number. */
&nbsp;        private final double full;
&nbsp;
&nbsp;        /** High order bits. */
&nbsp;        private final double high;
&nbsp;
&nbsp;        /** Low order bits. */
&nbsp;        private final double low;
&nbsp;
&nbsp;        /** Simple constructor.
&nbsp;         * @param x number to split
&nbsp;         */
<b class="nc">&nbsp;        Split(final double x) {</b>
<b class="nc">&nbsp;            full = x;</b>
<b class="nc">&nbsp;            high = Double.longBitsToDouble(Double.doubleToRawLongBits(x) &amp; ((-1L) &lt;&lt; 27));</b>
<b class="nc">&nbsp;            low  = x - high;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Simple constructor.
&nbsp;         * @param high high order bits
&nbsp;         * @param low low order bits
&nbsp;         */
&nbsp;        Split(final double high, final double low) {
<b class="nc">&nbsp;            this(high == 0.0 ? (low == 0.0 &amp;&amp; Double.doubleToRawLongBits(high) == Long.MIN_VALUE /* negative zero */ ? -0.0 : low) : high + low, high, low);</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Simple constructor.
&nbsp;         * @param full full number
&nbsp;         * @param high high order bits
&nbsp;         * @param low low order bits
&nbsp;         */
<b class="nc">&nbsp;        Split(final double full, final double high, final double low) {</b>
<b class="nc">&nbsp;            this.full = full;</b>
<b class="nc">&nbsp;            this.high = high;</b>
<b class="nc">&nbsp;            this.low  = low;</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Multiply the instance by another one.
&nbsp;         * @param b other instance to multiply by
&nbsp;         * @return product
&nbsp;         */
&nbsp;        public Split multiply(final Split b) {
&nbsp;            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<b class="nc">&nbsp;            final Split  mulBasic  = new Split(full * b.full);</b>
<b class="nc">&nbsp;            final double mulError  = low * b.low - (((mulBasic.full - high * b.high) - low * b.high) - high * b.low);</b>
<b class="nc">&nbsp;            return new Split(mulBasic.high, mulBasic.low + mulError);</b>
&nbsp;        }
&nbsp;
&nbsp;        /** Compute the reciprocal of the instance.
&nbsp;         * @return reciprocal of the instance
&nbsp;         */
&nbsp;        public Split reciprocal() {
&nbsp;
<b class="nc">&nbsp;            final double approximateInv = 1.0 / full;</b>
<b class="nc">&nbsp;            final Split  splitInv       = new Split(approximateInv);</b>
&nbsp;
&nbsp;            // if 1.0/d were computed perfectly, remultiplying it by d should give 1.0
&nbsp;            // we want to estimate the error so we can fix the low order bits of approximateInvLow
&nbsp;            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties
<b class="nc">&nbsp;            final Split product = multiply(splitInv);</b>
<b class="nc">&nbsp;            final double error  = (product.high - 1) + product.low;</b>
&nbsp;
&nbsp;            // better accuracy estimate of reciprocal
<b class="nc">&nbsp;            return Double.isNaN(error) ? splitInv : new Split(splitInv.high, splitInv.low - error / full);</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        /** Computes this^e.
&nbsp;         * @param e exponent (beware, here it MUST be &gt; 0; the only exclusion is Long.MIN_VALUE)
&nbsp;         * @return d^e, split in high and low bits
&nbsp;         * @since 3.6
&nbsp;         */
&nbsp;        private Split pow(final long e) {
&nbsp;
&nbsp;            // prepare result
<b class="nc">&nbsp;            Split result = new Split(1);</b>
&nbsp;
&nbsp;            // d^(2p)
<b class="nc">&nbsp;            Split d2p = new Split(full, high, low);</b>
&nbsp;
<b class="nc">&nbsp;            for (long p = e; p != 0; p &gt;&gt;&gt;= 1) {</b>
&nbsp;
<b class="nc">&nbsp;                if ((p &amp; 0x1) != 0) {</b>
&nbsp;                    // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm
<b class="nc">&nbsp;                    result = result.multiply(d2p);</b>
&nbsp;                }
&nbsp;
&nbsp;                // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm
<b class="nc">&nbsp;                d2p = d2p.multiply(d2p);</b>
&nbsp;
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (Double.isNaN(result.full)) {</b>
<b class="nc">&nbsp;                if (Double.isNaN(full)) {</b>
<b class="nc">&nbsp;                    return Split.NAN;</b>
&nbsp;                } else {
&nbsp;                    // some intermediate numbers exceeded capacity,
&nbsp;                    // and the low order bits became NaN (because infinity - infinity = NaN)
<b class="nc">&nbsp;                    if (AccurateMath.abs(full) &lt; 1) {</b>
<b class="nc">&nbsp;                        return new Split(AccurateMath.copySign(0.0, full), 0.0);</b>
<b class="nc">&nbsp;                    } else if (full &lt; 0 &amp;&amp; (e &amp; 0x1) == 1) {</b>
<b class="nc">&nbsp;                        return Split.NEGATIVE_INFINITY;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return Split.POSITIVE_INFINITY;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Computes sin(x) - x, where |x| &lt; 1/16.
&nbsp;     *  Use a Remez polynomial approximation.
&nbsp;     *  @param x a number smaller than 1/16
&nbsp;     *  @return sin(x) - x
&nbsp;     */
&nbsp;    private static double polySine(final double x) {
<b class="nc">&nbsp;        double x2 = x * x;</b>
&nbsp;
<b class="nc">&nbsp;        double p = 2.7553817452272217E-6;</b>
<b class="nc">&nbsp;        p = p * x2 + -1.9841269659586505E-4;</b>
<b class="nc">&nbsp;        p = p * x2 + 0.008333333333329196;</b>
<b class="nc">&nbsp;        p = p * x2 + -0.16666666666666666;</b>
&nbsp;        //p *= x2;
&nbsp;        //p *= x;
<b class="nc">&nbsp;        p = p * x2 * x;</b>
&nbsp;
<b class="nc">&nbsp;        return p;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Computes cos(x) - 1, where |x| &lt; 1/16.
&nbsp;     *  Use a Remez polynomial approximation.
&nbsp;     *  @param x a number smaller than 1/16
&nbsp;     *  @return cos(x) - 1
&nbsp;     */
&nbsp;    private static double polyCosine(double x) {
<b class="nc">&nbsp;        double x2 = x * x;</b>
&nbsp;
<b class="nc">&nbsp;        double p = 2.479773539153719E-5;</b>
<b class="nc">&nbsp;        p = p * x2 + -0.0013888888689039883;</b>
<b class="nc">&nbsp;        p = p * x2 + 0.041666666666621166;</b>
<b class="nc">&nbsp;        p = p * x2 + -0.49999999999999994;</b>
<b class="nc">&nbsp;        p *= x2;</b>
&nbsp;
<b class="nc">&nbsp;        return p;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Compute sine over the first quadrant (0 &lt; x &lt; pi/2).
&nbsp;     *  Use combination of table lookup and rational polynomial expansion.
&nbsp;     *  @param xa number from which sine is requested
&nbsp;     *  @param xb extra bits for x (may be 0.0)
&nbsp;     *  @return sin(xa + xb)
&nbsp;     */
&nbsp;    private static double sinQ(double xa, double xb) {
<b class="nc">&nbsp;        int idx = (int) ((xa * 8.0) + 0.5);</b>
<b class="nc">&nbsp;        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;</b>
&nbsp;
&nbsp;        // Table lookups
<b class="nc">&nbsp;        final double sintA = SINE_TABLE_A[idx];</b>
<b class="nc">&nbsp;        final double sintB = SINE_TABLE_B[idx];</b>
<b class="nc">&nbsp;        final double costA = COSINE_TABLE_A[idx];</b>
<b class="nc">&nbsp;        final double costB = COSINE_TABLE_B[idx];</b>
&nbsp;
&nbsp;        // Polynomial eval of sin(epsilon), cos(epsilon)
<b class="nc">&nbsp;        double sinEpsA = epsilon;</b>
<b class="nc">&nbsp;        double sinEpsB = polySine(epsilon);</b>
<b class="nc">&nbsp;        final double cosEpsA = 1.0;</b>
<b class="nc">&nbsp;        final double cosEpsB = polyCosine(epsilon);</b>
&nbsp;
&nbsp;        // Split epsilon   xa + xb = x
<b class="nc">&nbsp;        final double temp = sinEpsA * HEX_40000000;</b>
<b class="nc">&nbsp;        double temp2 = (sinEpsA + temp) - temp;</b>
<b class="nc">&nbsp;        sinEpsB +=  sinEpsA - temp2;</b>
<b class="nc">&nbsp;        sinEpsA = temp2;</b>
&nbsp;
&nbsp;        /* Compute sin(x) by angle addition formula */
&nbsp;        double result;
&nbsp;
&nbsp;        /* Compute the following sum:
&nbsp;         *
&nbsp;         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
&nbsp;         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
&nbsp;         *
&nbsp;         * Ranges of elements
&nbsp;         *
&nbsp;         * xxxtA   0            PI/2
&nbsp;         * xxxtB   -1.5e-9      1.5e-9
&nbsp;         * sinEpsA -0.0625      0.0625
&nbsp;         * sinEpsB -6e-11       6e-11
&nbsp;         * cosEpsA  1.0
&nbsp;         * cosEpsB  0           -0.0625
&nbsp;         *
&nbsp;         */
&nbsp;
&nbsp;        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
&nbsp;        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
&nbsp;
&nbsp;        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;
&nbsp;        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
<b class="nc">&nbsp;        double a = 0;</b>
<b class="nc">&nbsp;        double b = 0;</b>
&nbsp;
<b class="nc">&nbsp;        double t = sintA;</b>
<b class="nc">&nbsp;        double c = a + t;</b>
<b class="nc">&nbsp;        double d = -(c - a - t);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        t = costA * sinEpsA;</b>
<b class="nc">&nbsp;        c = a + t;</b>
<b class="nc">&nbsp;        d = -(c - a - t);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        b = b + sintA * cosEpsB + costA * sinEpsB;</b>
&nbsp;        /*
&nbsp;        t = sintA*cosEpsB;
&nbsp;        c = a + t;
&nbsp;        d = -(c - a - t);
&nbsp;        a = c;
&nbsp;        b = b + d;
&nbsp;
&nbsp;        t = costA*sinEpsB;
&nbsp;        c = a + t;
&nbsp;        d = -(c - a - t);
&nbsp;        a = c;
&nbsp;        b = b + d;
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;</b>
&nbsp;        /*
&nbsp;        t = sintB;
&nbsp;        c = a + t;
&nbsp;        d = -(c - a - t);
&nbsp;        a = c;
&nbsp;        b = b + d;
&nbsp;
&nbsp;        t = costB*sinEpsA;
&nbsp;        c = a + t;
&nbsp;        d = -(c - a - t);
&nbsp;        a = c;
&nbsp;        b = b + d;
&nbsp;
&nbsp;        t = sintB*cosEpsB;
&nbsp;        c = a + t;
&nbsp;        d = -(c - a - t);
&nbsp;        a = c;
&nbsp;        b = b + d;
&nbsp;
&nbsp;        t = costB*sinEpsB;
&nbsp;        c = a + t;
&nbsp;        d = -(c - a - t);
&nbsp;        a = c;
&nbsp;        b = b + d;
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;        if (xb != 0.0) {</b>
<b class="nc">&nbsp;            t = ((costA + costB) * (cosEpsA + cosEpsB) -</b>
&nbsp;                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb
<b class="nc">&nbsp;            c = a + t;</b>
<b class="nc">&nbsp;            d = -(c - a - t);</b>
<b class="nc">&nbsp;            a = c;</b>
<b class="nc">&nbsp;            b += d;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        result = a + b;</b>
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compute cosine in the first quadrant by subtracting input from PI/2 and
&nbsp;     * then calling sinQ.  This is more accurate as the input approaches PI/2.
&nbsp;     *  @param xa number from which cosine is requested
&nbsp;     *  @param xb extra bits for x (may be 0.0)
&nbsp;     *  @return cos(xa + xb)
&nbsp;     */
&nbsp;    private static double cosQ(double xa, double xb) {
<b class="nc">&nbsp;        final double pi2a = 1.5707963267948966;</b>
<b class="nc">&nbsp;        final double pi2b = 6.123233995736766E-17;</b>
&nbsp;
<b class="nc">&nbsp;        final double a = pi2a - xa;</b>
<b class="nc">&nbsp;        double b = -(a - pi2a + xa);</b>
<b class="nc">&nbsp;        b += pi2b - xb;</b>
&nbsp;
<b class="nc">&nbsp;        return sinQ(a, b);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Compute tangent (or cotangent) over the first quadrant.   0 &lt; x &lt; pi/2
&nbsp;     *  Use combination of table lookup and rational polynomial expansion.
&nbsp;     *  @param xa number from which sine is requested
&nbsp;     *  @param xb extra bits for x (may be 0.0)
&nbsp;     *  @param cotanFlag if true, compute the cotangent instead of the tangent
&nbsp;     *  @return tan(xa+xb) (or cotangent, depending on cotanFlag)
&nbsp;     */
&nbsp;    private static double tanQ(double xa, double xb, boolean cotanFlag) {
&nbsp;
<b class="nc">&nbsp;        int idx = (int) ((xa * 8.0) + 0.5);</b>
<b class="nc">&nbsp;        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;</b>
&nbsp;
&nbsp;        // Table lookups
<b class="nc">&nbsp;        final double sintA = SINE_TABLE_A[idx];</b>
<b class="nc">&nbsp;        final double sintB = SINE_TABLE_B[idx];</b>
<b class="nc">&nbsp;        final double costA = COSINE_TABLE_A[idx];</b>
<b class="nc">&nbsp;        final double costB = COSINE_TABLE_B[idx];</b>
&nbsp;
&nbsp;        // Polynomial eval of sin(epsilon), cos(epsilon)
<b class="nc">&nbsp;        double sinEpsA = epsilon;</b>
<b class="nc">&nbsp;        double sinEpsB = polySine(epsilon);</b>
<b class="nc">&nbsp;        final double cosEpsA = 1.0;</b>
<b class="nc">&nbsp;        final double cosEpsB = polyCosine(epsilon);</b>
&nbsp;
&nbsp;        // Split epsilon   xa + xb = x
<b class="nc">&nbsp;        double temp = sinEpsA * HEX_40000000;</b>
<b class="nc">&nbsp;        double temp2 = (sinEpsA + temp) - temp;</b>
<b class="nc">&nbsp;        sinEpsB +=  sinEpsA - temp2;</b>
<b class="nc">&nbsp;        sinEpsA = temp2;</b>
&nbsp;
&nbsp;        /* Compute sin(x) by angle addition formula */
&nbsp;
&nbsp;        /* Compute the following sum:
&nbsp;         *
&nbsp;         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
&nbsp;         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
&nbsp;         *
&nbsp;         * Ranges of elements
&nbsp;         *
&nbsp;         * xxxtA   0            PI/2
&nbsp;         * xxxtB   -1.5e-9      1.5e-9
&nbsp;         * sinEpsA -0.0625      0.0625
&nbsp;         * sinEpsB -6e-11       6e-11
&nbsp;         * cosEpsA  1.0
&nbsp;         * cosEpsB  0           -0.0625
&nbsp;         *
&nbsp;         */
&nbsp;
&nbsp;        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +
&nbsp;        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;
&nbsp;
&nbsp;        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;
&nbsp;        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;
<b class="nc">&nbsp;        double a = 0;</b>
<b class="nc">&nbsp;        double b = 0;</b>
&nbsp;
&nbsp;        // Compute sine
<b class="nc">&nbsp;        double t = sintA;</b>
<b class="nc">&nbsp;        double c = a + t;</b>
<b class="nc">&nbsp;        double d = -(c - a - t);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        t = costA * sinEpsA;</b>
<b class="nc">&nbsp;        c = a + t;</b>
<b class="nc">&nbsp;        d = -(c - a - t);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        b += sintA * cosEpsB + costA * sinEpsB;</b>
<b class="nc">&nbsp;        b += sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;</b>
&nbsp;
<b class="nc">&nbsp;        double sina = a + b;</b>
<b class="nc">&nbsp;        double sinb = -(sina - a - b);</b>
&nbsp;
&nbsp;        // Compute cosine
&nbsp;
<b class="nc">&nbsp;        a = b = c = d = 0.0;</b>
&nbsp;
<b class="nc">&nbsp;        t = costA * cosEpsA;</b>
<b class="nc">&nbsp;        c = a + t;</b>
<b class="nc">&nbsp;        d = -(c - a - t);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        t = -sintA * sinEpsA;</b>
<b class="nc">&nbsp;        c = a + t;</b>
<b class="nc">&nbsp;        d = -(c - a - t);</b>
<b class="nc">&nbsp;        a = c;</b>
<b class="nc">&nbsp;        b += d;</b>
&nbsp;
<b class="nc">&nbsp;        b += costB * cosEpsA + costA * cosEpsB + costB * cosEpsB;</b>
<b class="nc">&nbsp;        b -= sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB;</b>
&nbsp;
<b class="nc">&nbsp;        double cosa = a + b;</b>
<b class="nc">&nbsp;        double cosb = -(cosa - a - b);</b>
&nbsp;
<b class="nc">&nbsp;        if (cotanFlag) {</b>
&nbsp;            double tmp;
<b class="nc">&nbsp;            tmp = cosa; cosa = sina; sina = tmp;</b>
<b class="nc">&nbsp;            tmp = cosb; cosb = sinb; sinb = tmp;</b>
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        /* estimate and correct, compute 1.0/(cosa+cosb) */
&nbsp;        /*
&nbsp;    double est = (sina+sinb)/(cosa+cosb);
&nbsp;    double err = (sina - cosa*est) + (sinb - cosb*est);
&nbsp;    est += err/(cosa+cosb);
&nbsp;    err = (sina - cosa*est) + (sinb - cosb*est);
&nbsp;         */
&nbsp;
&nbsp;        // f(x) = 1/x,   f&#39;(x) = -1/x^2
&nbsp;
<b class="nc">&nbsp;        double est = sina / cosa;</b>
&nbsp;
&nbsp;        /* Split the estimate to get more accurate read on division rounding */
<b class="nc">&nbsp;        temp = est * HEX_40000000;</b>
<b class="nc">&nbsp;        double esta = (est + temp) - temp;</b>
<b class="nc">&nbsp;        double estb =  est - esta;</b>
&nbsp;
<b class="nc">&nbsp;        temp = cosa * HEX_40000000;</b>
<b class="nc">&nbsp;        double cosaa = (cosa + temp) - temp;</b>
<b class="nc">&nbsp;        double cosab =  cosa - cosaa;</b>
&nbsp;
&nbsp;        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding
<b class="nc">&nbsp;        double err = (sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab) / cosa;  // Correction for division rounding</b>
<b class="nc">&nbsp;        err += sinb / cosa;                   // Change in est due to sinb</b>
<b class="nc">&nbsp;        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb</b>
&nbsp;
<b class="nc">&nbsp;        if (xb != 0.0) {</b>
&nbsp;            // tan&#39; = 1 + tan^2      cot&#39; = -(1 + cot^2)
&nbsp;            // Approximate impact of xb
<b class="nc">&nbsp;            double xbadj = xb + est * est * xb;</b>
<b class="nc">&nbsp;            if (cotanFlag) {</b>
<b class="nc">&nbsp;                xbadj = -xbadj;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            err += xbadj;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return est + err;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Reduce the input argument using the Payne and Hanek method.
&nbsp;     *  This is good for all inputs 0.0 &lt; x &lt; inf
&nbsp;     *  Output is remainder after dividing by PI/2
&nbsp;     *  The result array should contain 3 numbers.
&nbsp;     *  result[0] is the integer portion, so mod 4 this gives the quadrant.
&nbsp;     *  result[1] is the upper bits of the remainder
&nbsp;     *  result[2] is the lower bits of the remainder
&nbsp;     *
&nbsp;     * @param x number to reduce
&nbsp;     * @param result placeholder where to put the result
&nbsp;     */
&nbsp;    private static void reducePayneHanek(double x, double[] result) {
&nbsp;        /* Convert input double to bits */
<b class="nc">&nbsp;        long inbits = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;        int exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
&nbsp;
&nbsp;        /* Convert to fixed point representation */
<b class="nc">&nbsp;        inbits &amp;= 0x000fffffffffffffL;</b>
<b class="nc">&nbsp;        inbits |= 0x0010000000000000L;</b>
&nbsp;
&nbsp;        /* Normalize input to be between 0.5 and 1.0 */
<b class="nc">&nbsp;        exponent++;</b>
<b class="nc">&nbsp;        inbits &lt;&lt;= 11;</b>
&nbsp;
&nbsp;        /* Based on the exponent, get a shifted copy of recip2pi */
&nbsp;        long shpi0;
&nbsp;        long shpiA;
&nbsp;        long shpiB;
<b class="nc">&nbsp;        int idx = exponent &gt;&gt; 6;</b>
<b class="nc">&nbsp;        int shift = exponent - (idx &lt;&lt; 6);</b>
&nbsp;
<b class="nc">&nbsp;        if (shift != 0) {</b>
<b class="nc">&nbsp;            shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx - 1] &lt;&lt; shift);</b>
<b class="nc">&nbsp;            shpi0 |= RECIP_2PI[idx] &gt;&gt;&gt; (64 - shift);</b>
<b class="nc">&nbsp;            shpiA = (RECIP_2PI[idx] &lt;&lt; shift) | (RECIP_2PI[idx + 1] &gt;&gt;&gt; (64 - shift));</b>
<b class="nc">&nbsp;            shpiB = (RECIP_2PI[idx + 1] &lt;&lt; shift) | (RECIP_2PI[idx + 2] &gt;&gt;&gt; (64 - shift));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx - 1];</b>
<b class="nc">&nbsp;            shpiA = RECIP_2PI[idx];</b>
<b class="nc">&nbsp;            shpiB = RECIP_2PI[idx + 1];</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Multiply input by shpiA */
<b class="nc">&nbsp;        long a = inbits &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        long b = inbits &amp; 0xffffffffL;</b>
&nbsp;
<b class="nc">&nbsp;        long c = shpiA &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        long d = shpiA &amp; 0xffffffffL;</b>
&nbsp;
<b class="nc">&nbsp;        long ac = a * c;</b>
<b class="nc">&nbsp;        long bd = b * d;</b>
<b class="nc">&nbsp;        long bc = b * c;</b>
<b class="nc">&nbsp;        long ad = a * d;</b>
&nbsp;
<b class="nc">&nbsp;        long prodB = bd + (ad &lt;&lt; 32);</b>
<b class="nc">&nbsp;        long prodA = ac + (ad &gt;&gt;&gt; 32);</b>
&nbsp;
<b class="nc">&nbsp;        boolean bita = (bd &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        boolean bitb = (ad &amp; 0x80000000L) != 0;</b>
<b class="nc">&nbsp;        boolean bitsum = (prodB &amp; 0x8000000000000000L) != 0;</b>
&nbsp;
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prodA++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bita = (prodB &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        bitb = (bc &amp; 0x80000000L) != 0;</b>
&nbsp;
<b class="nc">&nbsp;        prodB += bc &lt;&lt; 32;</b>
<b class="nc">&nbsp;        prodA += bc &gt;&gt;&gt; 32;</b>
&nbsp;
<b class="nc">&nbsp;        bitsum = (prodB &amp; 0x8000000000000000L) != 0;</b>
&nbsp;
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prodA++;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Multiply input by shpiB */
<b class="nc">&nbsp;        c = shpiB &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        d = shpiB &amp; 0xffffffffL;</b>
<b class="nc">&nbsp;        ac = a * c;</b>
<b class="nc">&nbsp;        bc = b * c;</b>
<b class="nc">&nbsp;        ad = a * d;</b>
&nbsp;
&nbsp;        /* Collect terms */
<b class="nc">&nbsp;        ac += (bc + ad) &gt;&gt;&gt; 32;</b>
&nbsp;
<b class="nc">&nbsp;        bita = (prodB &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        bitb = (ac &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        prodB += ac;</b>
<b class="nc">&nbsp;        bitsum = (prodB &amp; 0x8000000000000000L) != 0;</b>
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prodA++;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Multiply by shpi0 */
<b class="nc">&nbsp;        c = shpi0 &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        d = shpi0 &amp; 0xffffffffL;</b>
&nbsp;
<b class="nc">&nbsp;        bd = b * d;</b>
<b class="nc">&nbsp;        bc = b * c;</b>
<b class="nc">&nbsp;        ad = a * d;</b>
&nbsp;
<b class="nc">&nbsp;        prodA += bd + ((bc + ad) &lt;&lt; 32);</b>
&nbsp;
&nbsp;        /*
&nbsp;         * prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of
&nbsp;         * PI/2, so use the following steps:
&nbsp;         * 1.) multiply by 4.
&nbsp;         * 2.) do a fixed point muliply by PI/4.
&nbsp;         * 3.) Convert to floating point.
&nbsp;         * 4.) Multiply by 2
&nbsp;         */
&nbsp;
&nbsp;        /* This identifies the quadrant */
<b class="nc">&nbsp;        int intPart = (int)(prodA &gt;&gt;&gt; 62);</b>
&nbsp;
&nbsp;        /* Multiply by 4 */
<b class="nc">&nbsp;        prodA &lt;&lt;= 2;</b>
<b class="nc">&nbsp;        prodA |= prodB &gt;&gt;&gt; 62;</b>
<b class="nc">&nbsp;        prodB &lt;&lt;= 2;</b>
&nbsp;
&nbsp;        /* Multiply by PI/4 */
<b class="nc">&nbsp;        a = prodA &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        b = prodA &amp; 0xffffffffL;</b>
&nbsp;
<b class="nc">&nbsp;        c = PI_O_4_BITS[0] &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        d = PI_O_4_BITS[0] &amp; 0xffffffffL;</b>
&nbsp;
<b class="nc">&nbsp;        ac = a * c;</b>
<b class="nc">&nbsp;        bd = b * d;</b>
<b class="nc">&nbsp;        bc = b * c;</b>
<b class="nc">&nbsp;        ad = a * d;</b>
&nbsp;
<b class="nc">&nbsp;        long prod2B = bd + (ad &lt;&lt; 32);</b>
<b class="nc">&nbsp;        long prod2A = ac + (ad &gt;&gt;&gt; 32);</b>
&nbsp;
<b class="nc">&nbsp;        bita = (bd &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        bitb = (ad &amp; 0x80000000L) != 0;</b>
<b class="nc">&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
&nbsp;
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prod2A++;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        bita = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        bitb = (bc &amp; 0x80000000L) != 0;</b>
&nbsp;
<b class="nc">&nbsp;        prod2B += bc &lt;&lt; 32;</b>
<b class="nc">&nbsp;        prod2A += bc &gt;&gt;&gt; 32;</b>
&nbsp;
<b class="nc">&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
&nbsp;
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prod2A++;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Multiply input by pio4bits[1] */
<b class="nc">&nbsp;        c = PI_O_4_BITS[1] &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        d = PI_O_4_BITS[1] &amp; 0xffffffffL;</b>
<b class="nc">&nbsp;        ac = a * c;</b>
<b class="nc">&nbsp;        bc = b * c;</b>
<b class="nc">&nbsp;        ad = a * d;</b>
&nbsp;
&nbsp;        /* Collect terms */
<b class="nc">&nbsp;        ac += (bc + ad) &gt;&gt;&gt; 32;</b>
&nbsp;
<b class="nc">&nbsp;        bita = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        bitb = (ac &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        prod2B += ac;</b>
<b class="nc">&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prod2A++;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Multiply inputB by pio4bits[0] */
<b class="nc">&nbsp;        a = prodB &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        b = prodB &amp; 0xffffffffL;</b>
<b class="nc">&nbsp;        c = PI_O_4_BITS[0] &gt;&gt;&gt; 32;</b>
<b class="nc">&nbsp;        d = PI_O_4_BITS[0] &amp; 0xffffffffL;</b>
<b class="nc">&nbsp;        ac = a * c;</b>
<b class="nc">&nbsp;        bc = b * c;</b>
<b class="nc">&nbsp;        ad = a * d;</b>
&nbsp;
&nbsp;        /* Collect terms */
<b class="nc">&nbsp;        ac += (bc + ad) &gt;&gt;&gt; 32;</b>
&nbsp;
<b class="nc">&nbsp;        bita = (prod2B &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        bitb = (ac &amp; 0x8000000000000000L) != 0;</b>
<b class="nc">&nbsp;        prod2B += ac;</b>
<b class="nc">&nbsp;        bitsum = (prod2B &amp; 0x8000000000000000L) != 0;</b>
&nbsp;        /* Carry */
<b class="nc">&nbsp;        if ((bita &amp;&amp; bitb) ||</b>
&nbsp;                ((bita || bitb) &amp;&amp; !bitsum)) {
<b class="nc">&nbsp;            prod2A++;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Convert to double */
<b class="nc">&nbsp;        double tmpA = (prod2A &gt;&gt;&gt; 12) / TWO_POWER_52;  // High order 52 bits</b>
<b class="nc">&nbsp;        double tmpB = (((prod2A &amp; 0xfffL) &lt;&lt; 40) + (prod2B &gt;&gt;&gt; 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits</b>
&nbsp;
<b class="nc">&nbsp;        double sumA = tmpA + tmpB;</b>
<b class="nc">&nbsp;        double sumB = -(sumA - tmpA - tmpB);</b>
&nbsp;
&nbsp;        /* Multiply by PI/2 and return */
<b class="nc">&nbsp;        result[0] = intPart;</b>
<b class="nc">&nbsp;        result[1] = sumA * 2.0;</b>
<b class="nc">&nbsp;        result[2] = sumB * 2.0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sine function.
&nbsp;     *
&nbsp;     * @param x Argument.
&nbsp;     * @return sin(x)
&nbsp;     */
&nbsp;    public static double sin(double x) {
<b class="nc">&nbsp;        boolean negative = false;</b>
<b class="nc">&nbsp;        int quadrant = 0;</b>
&nbsp;        double xa;
<b class="nc">&nbsp;        double xb = 0.0;</b>
&nbsp;
&nbsp;        /* Take absolute value of the input */
<b class="nc">&nbsp;        xa = x;</b>
<b class="nc">&nbsp;        if (x &lt; 0) {</b>
<b class="nc">&nbsp;            negative = true;</b>
<b class="nc">&nbsp;            xa = -xa;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Check for zero and negative zero */
<b class="nc">&nbsp;        if (xa == 0.0) {</b>
<b class="nc">&nbsp;            long bits = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;            if (bits &lt; 0) {</b>
<b class="nc">&nbsp;                return -0.0;</b>
&nbsp;            }
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Perform any argument reduction */
<b class="nc">&nbsp;        if (xa &gt; 3294198.0) {</b>
&nbsp;            // PI * (2**20)
&nbsp;            // Argument too big for CodyWaite reduction.  Must use
&nbsp;            // PayneHanek.
<b class="nc">&nbsp;            double[] reduceResults = new double[3];</b>
<b class="nc">&nbsp;            reducePayneHanek(xa, reduceResults);</b>
<b class="nc">&nbsp;            quadrant = ((int) reduceResults[0]) &amp; 3;</b>
<b class="nc">&nbsp;            xa = reduceResults[1];</b>
<b class="nc">&nbsp;            xb = reduceResults[2];</b>
<b class="nc">&nbsp;        } else if (xa &gt; 1.5707963267948966) {</b>
<b class="nc">&nbsp;            final CodyWaite cw = new CodyWaite(xa);</b>
<b class="nc">&nbsp;            quadrant = cw.getK() &amp; 3;</b>
<b class="nc">&nbsp;            xa = cw.getRemA();</b>
<b class="nc">&nbsp;            xb = cw.getRemB();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (negative) {</b>
<b class="nc">&nbsp;            quadrant ^= 2;  // Flip bit 1</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        switch (quadrant) {</b>
&nbsp;        case 0:
<b class="nc">&nbsp;            return sinQ(xa, xb);</b>
&nbsp;        case 1:
<b class="nc">&nbsp;            return cosQ(xa, xb);</b>
&nbsp;        case 2:
<b class="nc">&nbsp;            return -sinQ(xa, xb);</b>
&nbsp;        case 3:
<b class="nc">&nbsp;            return -cosQ(xa, xb);</b>
&nbsp;        default:
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Cosine function.
&nbsp;     *
&nbsp;     * @param x Argument.
&nbsp;     * @return cos(x)
&nbsp;     */
&nbsp;    public static double cos(double x) {
<b class="nc">&nbsp;        int quadrant = 0;</b>
&nbsp;
&nbsp;        /* Take absolute value of the input */
<b class="nc">&nbsp;        double xa = x;</b>
<b class="nc">&nbsp;        if (x &lt; 0) {</b>
<b class="nc">&nbsp;            xa = -xa;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Perform any argument reduction */
<b class="nc">&nbsp;        double xb = 0;</b>
<b class="nc">&nbsp;        if (xa &gt; 3294198.0) {</b>
&nbsp;            // PI * (2**20)
&nbsp;            // Argument too big for CodyWaite reduction.  Must use
&nbsp;            // PayneHanek.
<b class="nc">&nbsp;            double[] reduceResults = new double[3];</b>
<b class="nc">&nbsp;            reducePayneHanek(xa, reduceResults);</b>
<b class="nc">&nbsp;            quadrant = ((int) reduceResults[0]) &amp; 3;</b>
<b class="nc">&nbsp;            xa = reduceResults[1];</b>
<b class="nc">&nbsp;            xb = reduceResults[2];</b>
<b class="nc">&nbsp;        } else if (xa &gt; 1.5707963267948966) {</b>
<b class="nc">&nbsp;            final CodyWaite cw = new CodyWaite(xa);</b>
<b class="nc">&nbsp;            quadrant = cw.getK() &amp; 3;</b>
<b class="nc">&nbsp;            xa = cw.getRemA();</b>
<b class="nc">&nbsp;            xb = cw.getRemB();</b>
&nbsp;        }
&nbsp;
&nbsp;        //if (negative)
&nbsp;        //  quadrant = (quadrant + 2) % 4;
&nbsp;
<b class="nc">&nbsp;        switch (quadrant) {</b>
&nbsp;        case 0:
<b class="nc">&nbsp;            return cosQ(xa, xb);</b>
&nbsp;        case 1:
<b class="nc">&nbsp;            return -sinQ(xa, xb);</b>
&nbsp;        case 2:
<b class="nc">&nbsp;            return -cosQ(xa, xb);</b>
&nbsp;        case 3:
<b class="nc">&nbsp;            return sinQ(xa, xb);</b>
&nbsp;        default:
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tangent function.
&nbsp;     *
&nbsp;     * @param x Argument.
&nbsp;     * @return tan(x)
&nbsp;     */
&nbsp;    public static double tan(double x) {
<b class="nc">&nbsp;        boolean negative = false;</b>
<b class="nc">&nbsp;        int quadrant = 0;</b>
&nbsp;
&nbsp;        /* Take absolute value of the input */
<b class="nc">&nbsp;        double xa = x;</b>
<b class="nc">&nbsp;        if (x &lt; 0) {</b>
<b class="nc">&nbsp;            negative = true;</b>
<b class="nc">&nbsp;            xa = -xa;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Check for zero and negative zero */
<b class="nc">&nbsp;        if (xa == 0.0) {</b>
<b class="nc">&nbsp;            long bits = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;            if (bits &lt; 0) {</b>
<b class="nc">&nbsp;                return -0.0;</b>
&nbsp;            }
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (xa != xa || xa == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Perform any argument reduction */
<b class="nc">&nbsp;        double xb = 0;</b>
<b class="nc">&nbsp;        if (xa &gt; 3294198.0) {</b>
&nbsp;            // PI * (2**20)
&nbsp;            // Argument too big for CodyWaite reduction.  Must use
&nbsp;            // PayneHanek.
<b class="nc">&nbsp;            double[] reduceResults = new double[3];</b>
<b class="nc">&nbsp;            reducePayneHanek(xa, reduceResults);</b>
<b class="nc">&nbsp;            quadrant = ((int) reduceResults[0]) &amp; 3;</b>
<b class="nc">&nbsp;            xa = reduceResults[1];</b>
<b class="nc">&nbsp;            xb = reduceResults[2];</b>
<b class="nc">&nbsp;        } else if (xa &gt; 1.5707963267948966) {</b>
<b class="nc">&nbsp;            final CodyWaite cw = new CodyWaite(xa);</b>
<b class="nc">&nbsp;            quadrant = cw.getK() &amp; 3;</b>
<b class="nc">&nbsp;            xa = cw.getRemA();</b>
<b class="nc">&nbsp;            xb = cw.getRemB();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (xa &gt; 1.5) {</b>
&nbsp;            // Accuracy suffers between 1.5 and PI/2
<b class="nc">&nbsp;            final double pi2a = 1.5707963267948966;</b>
<b class="nc">&nbsp;            final double pi2b = 6.123233995736766E-17;</b>
&nbsp;
<b class="nc">&nbsp;            final double a = pi2a - xa;</b>
<b class="nc">&nbsp;            double b = -(a - pi2a + xa);</b>
<b class="nc">&nbsp;            b += pi2b - xb;</b>
&nbsp;
<b class="nc">&nbsp;            xa = a + b;</b>
<b class="nc">&nbsp;            xb = -(xa - a - b);</b>
<b class="nc">&nbsp;            quadrant ^= 1;</b>
<b class="nc">&nbsp;            negative ^= true;</b>
&nbsp;        }
&nbsp;
&nbsp;        double result;
<b class="nc">&nbsp;        if ((quadrant &amp; 1) == 0) {</b>
<b class="nc">&nbsp;            result = tanQ(xa, xb, false);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            result = -tanQ(xa, xb, true);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (negative) {</b>
<b class="nc">&nbsp;            result = -result;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Arctangent function.
&nbsp;     *  @param x a number
&nbsp;     *  @return atan(x)
&nbsp;     */
&nbsp;    public static double atan(double x) {
<b class="nc">&nbsp;        return atan(x, 0.0, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Internal helper function to compute arctangent.
&nbsp;     * @param xa number from which arctangent is requested
&nbsp;     * @param xb extra bits for x (may be 0.0)
&nbsp;     * @param leftPlane if true, result angle must be put in the left half plane
&nbsp;     * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)
&nbsp;     */
&nbsp;    private static double atan(double xa, double xb, boolean leftPlane) {
<b class="nc">&nbsp;        if (xa == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="nc">&nbsp;            return leftPlane ? copySign(Math.PI, xa) : xa;</b>
&nbsp;        }
&nbsp;
&nbsp;        final boolean negate;
<b class="nc">&nbsp;        if (xa &lt; 0) {</b>
&nbsp;            // negative
<b class="nc">&nbsp;            xa = -xa;</b>
<b class="nc">&nbsp;            xb = -xb;</b>
<b class="nc">&nbsp;            negate = true;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            negate = false;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (xa &gt; 1.633123935319537E16) { // Very large input</b>
<b class="nc">&nbsp;            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */
&nbsp;        final int idx;
<b class="nc">&nbsp;        if (xa &lt; 1) {</b>
<b class="nc">&nbsp;            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            final double oneOverXa = 1 / xa;</b>
<b class="nc">&nbsp;            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final double ttA = TANGENT_TABLE_A[idx];</b>
<b class="nc">&nbsp;        final double ttB = TANGENT_TABLE_B[idx];</b>
&nbsp;
<b class="nc">&nbsp;        double epsA = xa - ttA;</b>
<b class="nc">&nbsp;        double epsB = -(epsA - xa + ttA);</b>
<b class="nc">&nbsp;        epsB += xb - ttB;</b>
&nbsp;
<b class="nc">&nbsp;        double temp = epsA + epsB;</b>
<b class="nc">&nbsp;        epsB = -(temp - epsA - epsB);</b>
<b class="nc">&nbsp;        epsA = temp;</b>
&nbsp;
&nbsp;        /* Compute eps = eps / (1.0 + xa*tangent) */
<b class="nc">&nbsp;        temp = xa * HEX_40000000;</b>
<b class="nc">&nbsp;        double ya = xa + temp - temp;</b>
<b class="nc">&nbsp;        double yb = xb + xa - ya;</b>
<b class="nc">&nbsp;        xa = ya;</b>
<b class="nc">&nbsp;        xb += yb;</b>
&nbsp;
&nbsp;        //if (idx &gt; 8 || idx == 0)
<b class="nc">&nbsp;        if (idx == 0) {</b>
&nbsp;            /* If the slope of the arctan is gentle enough (&lt; 0.45), this approximation will suffice */
&nbsp;            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);
<b class="nc">&nbsp;            final double denom = 1d / (1d + (xa + xb) * (ttA + ttB));</b>
&nbsp;            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);
<b class="nc">&nbsp;            ya = epsA * denom;</b>
<b class="nc">&nbsp;            yb = epsB * denom;</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            double temp2 = xa * ttA;</b>
<b class="nc">&nbsp;            double za = 1d + temp2;</b>
<b class="nc">&nbsp;            double zb = -(za - 1d - temp2);</b>
<b class="nc">&nbsp;            temp2 = xb * ttA + xa * ttB;</b>
<b class="nc">&nbsp;            temp = za + temp2;</b>
<b class="nc">&nbsp;            zb += -(temp - za - temp2);</b>
<b class="nc">&nbsp;            za = temp;</b>
&nbsp;
<b class="nc">&nbsp;            zb += xb * ttB;</b>
<b class="nc">&nbsp;            ya = epsA / za;</b>
&nbsp;
<b class="nc">&nbsp;            temp = ya * HEX_40000000;</b>
<b class="nc">&nbsp;            final double yaa = (ya + temp) - temp;</b>
<b class="nc">&nbsp;            final double yab = ya - yaa;</b>
&nbsp;
<b class="nc">&nbsp;            temp = za * HEX_40000000;</b>
<b class="nc">&nbsp;            final double zaa = (za + temp) - temp;</b>
<b class="nc">&nbsp;            final double zab = za - zaa;</b>
&nbsp;
&nbsp;            /* Correct for rounding in division */
<b class="nc">&nbsp;            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;</b>
&nbsp;
<b class="nc">&nbsp;            yb += -epsA * zb / za / za;</b>
<b class="nc">&nbsp;            yb += epsB / za;</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        epsA = ya;</b>
<b class="nc">&nbsp;        epsB = yb;</b>
&nbsp;
&nbsp;        /* Evaluate polynomial */
<b class="nc">&nbsp;        final double epsA2 = epsA * epsA;</b>
&nbsp;
&nbsp;        /*
&nbsp;    yb = -0.09001346640161823;
&nbsp;    yb = yb * epsA2 + 0.11110718400605211;
&nbsp;    yb = yb * epsA2 + -0.1428571349122913;
&nbsp;    yb = yb * epsA2 + 0.19999999999273194;
&nbsp;    yb = yb * epsA2 + -0.33333333333333093;
&nbsp;    yb = yb * epsA2 * epsA;
&nbsp;         */
&nbsp;
<b class="nc">&nbsp;        yb = 0.07490822288864472;</b>
<b class="nc">&nbsp;        yb = yb * epsA2 - 0.09088450866185192;</b>
<b class="nc">&nbsp;        yb = yb * epsA2 + 0.11111095942313305;</b>
<b class="nc">&nbsp;        yb = yb * epsA2 - 0.1428571423679182;</b>
<b class="nc">&nbsp;        yb = yb * epsA2 + 0.19999999999923582;</b>
<b class="nc">&nbsp;        yb = yb * epsA2 - 0.33333333333333287;</b>
<b class="nc">&nbsp;        yb = yb * epsA2 * epsA;</b>
&nbsp;
&nbsp;
<b class="nc">&nbsp;        ya = epsA;</b>
&nbsp;
<b class="nc">&nbsp;        temp = ya + yb;</b>
<b class="nc">&nbsp;        yb = -(temp - ya - yb);</b>
<b class="nc">&nbsp;        ya = temp;</b>
&nbsp;
&nbsp;        /* Add in effect of epsB.   atan&#39;(x) = 1/(1+x^2) */
<b class="nc">&nbsp;        yb += epsB / (1d + epsA * epsA);</b>
&nbsp;
<b class="nc">&nbsp;        final double eighths = EIGHTHS[idx];</b>
&nbsp;
&nbsp;        //result = yb + eighths[idx] + ya;
<b class="nc">&nbsp;        double za = eighths + ya;</b>
<b class="nc">&nbsp;        double zb = -(za - eighths - ya);</b>
<b class="nc">&nbsp;        temp = za + yb;</b>
<b class="nc">&nbsp;        zb += -(temp - za - yb);</b>
<b class="nc">&nbsp;        za = temp;</b>
&nbsp;
<b class="nc">&nbsp;        double result = za + zb;</b>
&nbsp;
<b class="nc">&nbsp;        if (leftPlane) {</b>
&nbsp;            // Result is in the left plane
<b class="nc">&nbsp;            final double resultb = -(result - za - zb);</b>
<b class="nc">&nbsp;            final double pia = 1.5707963267948966 * 2;</b>
<b class="nc">&nbsp;            final double pib = 6.123233995736766E-17 * 2;</b>
&nbsp;
<b class="nc">&nbsp;            za = pia - result;</b>
<b class="nc">&nbsp;            zb = -(za - pia + result);</b>
<b class="nc">&nbsp;            zb += pib - resultb;</b>
&nbsp;
<b class="nc">&nbsp;            result = za + zb;</b>
&nbsp;        }
&nbsp;
&nbsp;
<b class="nc">&nbsp;        if (negate ^ leftPlane) {</b>
<b class="nc">&nbsp;            result = -result;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Two arguments arctangent function.
&nbsp;     * @param y ordinate
&nbsp;     * @param x abscissa
&nbsp;     * @return phase angle of point (x,y) between {@code -PI} and {@code PI}
&nbsp;     */
&nbsp;    public static double atan2(double y, double x) {
<b class="nc">&nbsp;        if (Double.isNaN(x) || Double.isNaN(y)) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (y == 0) {</b>
<b class="nc">&nbsp;            final double invx = 1d / x;</b>
&nbsp;
<b class="nc">&nbsp;            if (invx == 0) { // X is infinite</b>
<b class="nc">&nbsp;                if (x &gt; 0) {</b>
<b class="nc">&nbsp;                    return y; // return +/- 0.0</b>
&nbsp;                }
<b class="nc">&nbsp;                return copySign(Math.PI, y);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (x &lt; 0 || invx &lt; 0) {</b>
<b class="nc">&nbsp;                return copySign(Math.PI, y);</b>
&nbsp;            }
<b class="nc">&nbsp;            return x * y;</b>
&nbsp;        }
&nbsp;
&nbsp;        // y cannot now be zero
&nbsp;
<b class="nc">&nbsp;        if (y == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            if (x == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;                return Math.PI * F_1_4;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (x == Double.NEGATIVE_INFINITY) {</b>
<b class="nc">&nbsp;                return Math.PI * F_3_4;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return Math.PI * F_1_2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (y == Double.NEGATIVE_INFINITY) {</b>
<b class="nc">&nbsp;            if (x == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;                return -Math.PI * F_1_4;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (x == Double.NEGATIVE_INFINITY) {</b>
<b class="nc">&nbsp;                return -Math.PI * F_3_4;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            return -Math.PI * F_1_2;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == Double.POSITIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return y &gt; 0 ? 0d : -0d;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == Double.NEGATIVE_INFINITY) {</b>
<b class="nc">&nbsp;            return y &gt; 0 ? Math.PI : -Math.PI;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Neither y nor x can be infinite or NAN here
&nbsp;
<b class="nc">&nbsp;        if (x == 0) {</b>
<b class="nc">&nbsp;            return y &gt; 0 ? Math.PI * F_1_2 : -Math.PI * F_1_2;</b>
&nbsp;        }
&nbsp;
&nbsp;        // Compute ratio r = y/x
<b class="nc">&nbsp;        final double r = y / x;</b>
<b class="nc">&nbsp;        if (Double.isInfinite(r)) { // bypass calculations that can create NaN</b>
<b class="nc">&nbsp;            return atan(r, 0, x &lt; 0);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double ra = doubleHighPart(r);</b>
<b class="nc">&nbsp;        double rb = r - ra;</b>
&nbsp;
&nbsp;        // Split x
<b class="nc">&nbsp;        final double xa = doubleHighPart(x);</b>
<b class="nc">&nbsp;        final double xb = x - xa;</b>
&nbsp;
<b class="nc">&nbsp;        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;</b>
&nbsp;
<b class="nc">&nbsp;        final double temp = ra + rb;</b>
<b class="nc">&nbsp;        rb = -(temp - ra - rb);</b>
<b class="nc">&nbsp;        ra = temp;</b>
&nbsp;
<b class="nc">&nbsp;        if (ra == 0) { // Fix up the sign so atan works correctly</b>
<b class="nc">&nbsp;            ra = copySign(0d, y);</b>
&nbsp;        }
&nbsp;
&nbsp;        // Call atan
<b class="nc">&nbsp;        return atan(ra, rb, x &lt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the arc sine of a number.
&nbsp;     * @param x number on which evaluation is done
&nbsp;     * @return arc sine of x
&nbsp;     */
&nbsp;    public static double asin(double x) {
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 1.0 || x &lt; -1.0) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == 1.0) {</b>
<b class="nc">&nbsp;            return Math.PI / 2.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == -1.0) {</b>
<b class="nc">&nbsp;            return -Math.PI / 2.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Compute asin(x) = atan(x/sqrt(1-x*x)) */
&nbsp;
&nbsp;        /* Split x */
<b class="nc">&nbsp;        double temp = x * HEX_40000000;</b>
<b class="nc">&nbsp;        final double xa = x + temp - temp;</b>
<b class="nc">&nbsp;        final double xb = x - xa;</b>
&nbsp;
&nbsp;        /* Square it */
<b class="nc">&nbsp;        double ya = xa * xa;</b>
<b class="nc">&nbsp;        double yb = xa * xb * 2.0 + xb * xb;</b>
&nbsp;
&nbsp;        /* Subtract from 1 */
<b class="nc">&nbsp;        ya = -ya;</b>
<b class="nc">&nbsp;        yb = -yb;</b>
&nbsp;
<b class="nc">&nbsp;        double za = 1.0 + ya;</b>
<b class="nc">&nbsp;        double zb = -(za - 1.0 - ya);</b>
&nbsp;
<b class="nc">&nbsp;        temp = za + yb;</b>
<b class="nc">&nbsp;        zb += -(temp - za - yb);</b>
<b class="nc">&nbsp;        za = temp;</b>
&nbsp;
&nbsp;        /* Square root */
&nbsp;        double y;
<b class="nc">&nbsp;        y = sqrt(za);</b>
<b class="nc">&nbsp;        temp = y * HEX_40000000;</b>
<b class="nc">&nbsp;        ya = y + temp - temp;</b>
<b class="nc">&nbsp;        yb = y - ya;</b>
&nbsp;
&nbsp;        /* Extend precision of sqrt */
<b class="nc">&nbsp;        yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);</b>
&nbsp;
&nbsp;        /* Contribution of zb to sqrt */
<b class="nc">&nbsp;        double dx = zb / (2.0 * y);</b>
&nbsp;
&nbsp;        // Compute ratio r = x/y
<b class="nc">&nbsp;        double r = x / y;</b>
<b class="nc">&nbsp;        temp = r * HEX_40000000;</b>
<b class="nc">&nbsp;        double ra = r + temp - temp;</b>
<b class="nc">&nbsp;        double rb = r - ra;</b>
&nbsp;
<b class="nc">&nbsp;        rb += (x - ra * ya - ra * yb - rb * ya - rb * yb) / y; // Correct for rounding in division</b>
<b class="nc">&nbsp;        rb += -x * dx / y / y; // Add in effect additional bits of sqrt.</b>
&nbsp;
<b class="nc">&nbsp;        temp = ra + rb;</b>
<b class="nc">&nbsp;        rb = -(temp - ra - rb);</b>
<b class="nc">&nbsp;        ra = temp;</b>
&nbsp;
<b class="nc">&nbsp;        return atan(ra, rb, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the arc cosine of a number.
&nbsp;     * @param x number on which evaluation is done
&nbsp;     * @return arc cosine of x
&nbsp;     */
&nbsp;    public static double acos(double x) {
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &gt; 1.0 || x &lt; -1.0) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == -1.0) {</b>
<b class="nc">&nbsp;            return Math.PI;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == 1.0) {</b>
<b class="nc">&nbsp;            return 0.0;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x == 0) {</b>
<b class="nc">&nbsp;            return Math.PI / 2.0;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Compute acos(x) = atan(sqrt(1-x*x)/x) */
&nbsp;
&nbsp;        /* Split x */
<b class="nc">&nbsp;        double temp = x * HEX_40000000;</b>
<b class="nc">&nbsp;        final double xa = x + temp - temp;</b>
<b class="nc">&nbsp;        final double xb = x - xa;</b>
&nbsp;
&nbsp;        /* Square it */
<b class="nc">&nbsp;        double ya = xa * xa;</b>
<b class="nc">&nbsp;        double yb = xa * xb * 2.0 + xb * xb;</b>
&nbsp;
&nbsp;        /* Subtract from 1 */
<b class="nc">&nbsp;        ya = -ya;</b>
<b class="nc">&nbsp;        yb = -yb;</b>
&nbsp;
<b class="nc">&nbsp;        double za = 1.0 + ya;</b>
<b class="nc">&nbsp;        double zb = -(za - 1.0 - ya);</b>
&nbsp;
<b class="nc">&nbsp;        temp = za + yb;</b>
<b class="nc">&nbsp;        zb += -(temp - za - yb);</b>
<b class="nc">&nbsp;        za = temp;</b>
&nbsp;
&nbsp;        /* Square root */
<b class="nc">&nbsp;        double y = sqrt(za);</b>
<b class="nc">&nbsp;        temp = y * HEX_40000000;</b>
<b class="nc">&nbsp;        ya = y + temp - temp;</b>
<b class="nc">&nbsp;        yb = y - ya;</b>
&nbsp;
&nbsp;        /* Extend precision of sqrt */
<b class="nc">&nbsp;        yb += (za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);</b>
&nbsp;
&nbsp;        /* Contribution of zb to sqrt */
<b class="nc">&nbsp;        yb += zb / (2.0 * y);</b>
<b class="nc">&nbsp;        y = ya + yb;</b>
<b class="nc">&nbsp;        yb = -(y - ya - yb);</b>
&nbsp;
&nbsp;        // Compute ratio r = y/x
<b class="nc">&nbsp;        double r = y / x;</b>
&nbsp;
&nbsp;        // Did r overflow?
<b class="nc">&nbsp;        if (Double.isInfinite(r)) { // x is effectively zero</b>
<b class="nc">&nbsp;            return Math.PI / 2; // so return the appropriate value</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        double ra = doubleHighPart(r);</b>
<b class="nc">&nbsp;        double rb = r - ra;</b>
&nbsp;
<b class="nc">&nbsp;        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x; // Correct for rounding in division</b>
<b class="nc">&nbsp;        rb += yb / x; // Add in effect additional bits of sqrt.</b>
&nbsp;
<b class="nc">&nbsp;        temp = ra + rb;</b>
<b class="nc">&nbsp;        rb = -(temp - ra - rb);</b>
<b class="nc">&nbsp;        ra = temp;</b>
&nbsp;
<b class="nc">&nbsp;        return atan(ra, rb, x &lt; 0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the cubic root of a number.
&nbsp;     * @param x number on which evaluation is done
&nbsp;     * @return cubic root of x
&nbsp;     */
&nbsp;    public static double cbrt(double x) {
&nbsp;        /* Convert input double to bits */
<b class="nc">&nbsp;        long inbits = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;        int exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
<b class="nc">&nbsp;        boolean subnormal = false;</b>
&nbsp;
<b class="nc">&nbsp;        if (exponent == -1023) {</b>
<b class="nc">&nbsp;            if (x == 0) {</b>
<b class="nc">&nbsp;                return x;</b>
&nbsp;            }
&nbsp;
&nbsp;            /* Subnormal, so normalize */
<b class="nc">&nbsp;            subnormal = true;</b>
<b class="nc">&nbsp;            x *= 1.8014398509481984E16; // 2^54</b>
<b class="nc">&nbsp;            inbits = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;            exponent = (int) ((inbits &gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (exponent == 1024) {</b>
&nbsp;            // Nan or infinity. Don&#39;t care which.
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* Divide the exponent by 3 */
<b class="nc">&nbsp;        int exp3 = exponent / 3;</b>
&nbsp;
&nbsp;        /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */
<b class="nc">&nbsp;        double p2 = Double.longBitsToDouble((inbits &amp; 0x8000000000000000L) | (long) (((exp3 + 1023) &amp; 0x7ff)) &lt;&lt; 52);</b>
&nbsp;
&nbsp;        /* This will be a number between 1 and 2 */
<b class="nc">&nbsp;        final double mant = Double.longBitsToDouble((inbits &amp; 0x000fffffffffffffL) | 0x3ff0000000000000L);</b>
&nbsp;
&nbsp;        /* Estimate the cube root of mant by polynomial */
<b class="nc">&nbsp;        double est = -0.010714690733195933;</b>
<b class="nc">&nbsp;        est = est * mant + 0.0875862700108075;</b>
<b class="nc">&nbsp;        est = est * mant + -0.3058015757857271;</b>
<b class="nc">&nbsp;        est = est * mant + 0.7249995199969751;</b>
<b class="nc">&nbsp;        est = est * mant + 0.5039018405998233;</b>
&nbsp;
<b class="nc">&nbsp;        est *= CBRTTWO[exponent % 3 + 2];</b>
&nbsp;
&nbsp;        // est should now be good to about 15 bits of precision.   Do 2 rounds of
&nbsp;        // Newton&#39;s method to get closer,  this should get us full double precision
&nbsp;        // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.
<b class="nc">&nbsp;        final double xs = x / (p2 * p2 * p2);</b>
<b class="nc">&nbsp;        est += (xs - est * est * est) / (3 * est * est);</b>
<b class="nc">&nbsp;        est += (xs - est * est * est) / (3 * est * est);</b>
&nbsp;
&nbsp;        // Do one round of Newton&#39;s method in extended precision to get the last bitright.
<b class="nc">&nbsp;        double temp = est * HEX_40000000;</b>
<b class="nc">&nbsp;        double ya = est + temp - temp;</b>
<b class="nc">&nbsp;        double yb = est - ya;</b>
&nbsp;
<b class="nc">&nbsp;        double za = ya * ya;</b>
<b class="nc">&nbsp;        double zb = ya * yb * 2.0 + yb * yb;</b>
<b class="nc">&nbsp;        temp = za * HEX_40000000;</b>
<b class="nc">&nbsp;        double temp2 = za + temp - temp;</b>
<b class="nc">&nbsp;        zb += za - temp2;</b>
<b class="nc">&nbsp;        za = temp2;</b>
&nbsp;
<b class="nc">&nbsp;        zb = za * yb + ya * zb + zb * yb;</b>
<b class="nc">&nbsp;        za *= ya;</b>
&nbsp;
<b class="nc">&nbsp;        double na = xs - za;</b>
<b class="nc">&nbsp;        double nb = -(na - xs + za);</b>
<b class="nc">&nbsp;        nb -= zb;</b>
&nbsp;
<b class="nc">&nbsp;        est += (na + nb) / (3 * est * est);</b>
&nbsp;
&nbsp;        /* Scale by a power of two, so this is exact. */
<b class="nc">&nbsp;        est *= p2;</b>
&nbsp;
<b class="nc">&nbsp;        if (subnormal) {</b>
<b class="nc">&nbsp;            est *= 3.814697265625E-6; // 2^-18</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return est;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Convert degrees to radians, with error of less than 0.5 ULP.
&nbsp;     *  @param x angle in degrees
&nbsp;     *  @return x converted into radians
&nbsp;     */
&nbsp;    public static double toRadians(double x) {
<b class="nc">&nbsp;        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        // These are PI/180 split into high and low order bits
<b class="nc">&nbsp;        final double facta = 0.01745329052209854;</b>
<b class="nc">&nbsp;        final double factb = 1.997844754509471E-9;</b>
&nbsp;
<b class="nc">&nbsp;        double xa = doubleHighPart(x);</b>
<b class="nc">&nbsp;        double xb = x - xa;</b>
&nbsp;
<b class="nc">&nbsp;        double result = xb * factb + xb * facta + xa * factb + xa * facta;</b>
<b class="nc">&nbsp;        if (result == 0) {</b>
<b class="nc">&nbsp;            result *= x; // ensure correct sign if calculation underflows</b>
&nbsp;        }
<b class="nc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     *  Convert radians to degrees, with error of less than 0.5 ULP.
&nbsp;     *  @param x angle in radians
&nbsp;     *  @return x converted into degrees
&nbsp;     */
&nbsp;    public static double toDegrees(double x) {
<b class="nc">&nbsp;        if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
&nbsp;        // These are 180/PI split into high and low order bits
<b class="nc">&nbsp;        final double facta = 57.2957763671875;</b>
<b class="nc">&nbsp;        final double factb = 3.145894820876798E-6;</b>
&nbsp;
<b class="nc">&nbsp;        double xa = doubleHighPart(x);</b>
<b class="nc">&nbsp;        double xb = x - xa;</b>
&nbsp;
<b class="nc">&nbsp;        return xb * factb + xb * facta + xa * factb + xa * facta;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Absolute value.
&nbsp;     * @param x number from which absolute value is requested
&nbsp;     * @return abs(x)
&nbsp;     */
&nbsp;    public static int abs(final int x) {
<b class="fc">&nbsp;        final int i = x &gt;&gt;&gt; 31;</b>
<b class="fc">&nbsp;        return (x ^ (~i + 1)) + i;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Absolute value.
&nbsp;     * @param x number from which absolute value is requested
&nbsp;     * @return abs(x)
&nbsp;     */
&nbsp;    public static long abs(final long x) {
<b class="nc">&nbsp;        final long l = x &gt;&gt;&gt; 63;</b>
&nbsp;        // l is one if x negative zero else
&nbsp;        // ~l+1 is zero if x is positive, -1 if x is negative
&nbsp;        // x^(~l+1) is x is x is positive, ~x if x is negative
&nbsp;        // add around
<b class="nc">&nbsp;        return (x ^ (~l + 1)) + l;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Absolute value.
&nbsp;     * @param x number from which absolute value is requested
&nbsp;     * @return abs(x)
&nbsp;     */
&nbsp;    public static float abs(final float x) {
<b class="nc">&nbsp;        return Float.intBitsToFloat(MASK_NON_SIGN_INT &amp; Float.floatToRawIntBits(x));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Absolute value.
&nbsp;     * @param x number from which absolute value is requested
&nbsp;     * @return abs(x)
&nbsp;     */
&nbsp;    public static double abs(double x) {
<b class="fc">&nbsp;        return Double.longBitsToDouble(MASK_NON_SIGN_LONG &amp; Double.doubleToRawLongBits(x));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compute least significant bit (Unit in Last Position) for a number.
&nbsp;     * @param x number from which ulp is requested
&nbsp;     * @return ulp(x)
&nbsp;     */
&nbsp;    public static double ulp(double x) {
<b class="nc">&nbsp;        if (Double.isInfinite(x)) {</b>
<b class="nc">&nbsp;            return Double.POSITIVE_INFINITY;</b>
&nbsp;        }
<b class="nc">&nbsp;        return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Compute least significant bit (Unit in Last Position) for a number.
&nbsp;     * @param x number from which ulp is requested
&nbsp;     * @return ulp(x)
&nbsp;     */
&nbsp;    public static float ulp(float x) {
<b class="nc">&nbsp;        if (Float.isInfinite(x)) {</b>
<b class="nc">&nbsp;            return Float.POSITIVE_INFINITY;</b>
&nbsp;        }
<b class="nc">&nbsp;        return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Multiply a double number by a power of 2.
&nbsp;     * @param d number to multiply
&nbsp;     * @param n power of 2
&nbsp;     * @return d &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;
&nbsp;     */
&nbsp;    public static double scalb(final double d, final int n) {
&nbsp;
&nbsp;        // first simple and fast handling when 2^n can be represented using normal numbers
<b class="nc">&nbsp;        if ((n &gt; -1023) &amp;&amp; (n &lt; 1024)) {</b>
<b class="nc">&nbsp;            return d * Double.longBitsToDouble(((long) (n + 1023)) &lt;&lt; 52);</b>
&nbsp;        }
&nbsp;
&nbsp;        // handle special cases
<b class="nc">&nbsp;        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {</b>
<b class="nc">&nbsp;            return d;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (n &lt; -2098) {</b>
<b class="nc">&nbsp;            return (d &gt; 0) ? 0.0 : -0.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (n &gt; 2097) {</b>
<b class="nc">&nbsp;            return (d &gt; 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
&nbsp;        // decompose d
<b class="nc">&nbsp;        final long bits = Double.doubleToRawLongBits(d);</b>
<b class="nc">&nbsp;        final long sign = bits &amp; 0x8000000000000000L;</b>
<b class="nc">&nbsp;        int  exponent   = ((int) (bits &gt;&gt;&gt; 52)) &amp; 0x7ff;</b>
<b class="nc">&nbsp;        long mantissa   = bits &amp; 0x000fffffffffffffL;</b>
&nbsp;
&nbsp;        // compute scaled exponent
<b class="nc">&nbsp;        int scaledExponent = exponent + n;</b>
&nbsp;
<b class="nc">&nbsp;        if (n &lt; 0) {</b>
&nbsp;            // we are really in the case n &lt;= -1023
<b class="nc">&nbsp;            if (scaledExponent &gt; 0) {</b>
&nbsp;                // both the input and the result are normal numbers, we only adjust the exponent
<b class="nc">&nbsp;                return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</b>
<b class="nc">&nbsp;            } else if (scaledExponent &gt; -53) {</b>
&nbsp;                // the input is a normal number and the result is a subnormal number
&nbsp;
&nbsp;                // recover the hidden mantissa bit
<b class="nc">&nbsp;                mantissa |= 1L &lt;&lt; 52;</b>
&nbsp;
&nbsp;                // scales down complete mantissa, hence losing least significant bits
<b class="nc">&nbsp;                final long mostSignificantLostBit = mantissa &amp; (1L &lt;&lt; (-scaledExponent));</b>
<b class="nc">&nbsp;                mantissa &gt;&gt;&gt;= 1 - scaledExponent;</b>
<b class="nc">&nbsp;                if (mostSignificantLostBit != 0) {</b>
&nbsp;                    // we need to add 1 bit to round up the result
<b class="nc">&nbsp;                    mantissa++;</b>
&nbsp;                }
<b class="nc">&nbsp;                return Double.longBitsToDouble(sign | mantissa);</b>
&nbsp;
&nbsp;            } else {
&nbsp;                // no need to compute the mantissa, the number scales down to 0
<b class="nc">&nbsp;                return (sign == 0L) ? 0.0 : -0.0;</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // we are really in the case n &gt;= 1024
<b class="nc">&nbsp;            if (exponent == 0) {</b>
&nbsp;
&nbsp;                // the input number is subnormal, normalize it
<b class="nc">&nbsp;                while ((mantissa &gt;&gt;&gt; 52) != 1) {</b>
<b class="nc">&nbsp;                    mantissa &lt;&lt;= 1;</b>
<b class="nc">&nbsp;                    --scaledExponent;</b>
&nbsp;                }
<b class="nc">&nbsp;                ++scaledExponent;</b>
<b class="nc">&nbsp;                mantissa &amp;= 0x000fffffffffffffL;</b>
&nbsp;
<b class="nc">&nbsp;                if (scaledExponent &lt; 2047) {</b>
<b class="nc">&nbsp;                    return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            } else if (scaledExponent &lt; 2047) {</b>
<b class="nc">&nbsp;                return Double.longBitsToDouble(sign | (((long) scaledExponent) &lt;&lt; 52) | mantissa);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Multiply a float number by a power of 2.
&nbsp;     * @param f number to multiply
&nbsp;     * @param n power of 2
&nbsp;     * @return f &amp;times; 2&lt;sup&gt;n&lt;/sup&gt;
&nbsp;     */
&nbsp;    public static float scalb(final float f, final int n) {
&nbsp;
&nbsp;        // first simple and fast handling when 2^n can be represented using normal numbers
<b class="nc">&nbsp;        if ((n &gt; -127) &amp;&amp; (n &lt; 128)) {</b>
<b class="nc">&nbsp;            return f * Float.intBitsToFloat((n + 127) &lt;&lt; 23);</b>
&nbsp;        }
&nbsp;
&nbsp;        // handle special cases
<b class="nc">&nbsp;        if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {</b>
<b class="nc">&nbsp;            return f;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (n &lt; -277) {</b>
<b class="nc">&nbsp;            return (f &gt; 0) ? 0.0f : -0.0f;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (n &gt; 276) {</b>
<b class="nc">&nbsp;            return (f &gt; 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</b>
&nbsp;        }
&nbsp;
&nbsp;        // decompose f
<b class="nc">&nbsp;        final int bits = Float.floatToIntBits(f);</b>
<b class="nc">&nbsp;        final int sign = bits &amp; 0x80000000;</b>
<b class="nc">&nbsp;        int  exponent  = (bits &gt;&gt;&gt; 23) &amp; 0xff;</b>
<b class="nc">&nbsp;        int mantissa   = bits &amp; 0x007fffff;</b>
&nbsp;
&nbsp;        // compute scaled exponent
<b class="nc">&nbsp;        int scaledExponent = exponent + n;</b>
&nbsp;
<b class="nc">&nbsp;        if (n &lt; 0) {</b>
&nbsp;            // we are really in the case n &lt;= -127
<b class="nc">&nbsp;            if (scaledExponent &gt; 0) {</b>
&nbsp;                // both the input and the result are normal numbers, we only adjust the exponent
<b class="nc">&nbsp;                return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</b>
<b class="nc">&nbsp;            } else if (scaledExponent &gt; -24) {</b>
&nbsp;                // the input is a normal number and the result is a subnormal number
&nbsp;
&nbsp;                // recover the hidden mantissa bit
<b class="nc">&nbsp;                mantissa |= 1 &lt;&lt; 23;</b>
&nbsp;
&nbsp;                // scales down complete mantissa, hence losing least significant bits
<b class="nc">&nbsp;                final int mostSignificantLostBit = mantissa &amp; (1 &lt;&lt; (-scaledExponent));</b>
<b class="nc">&nbsp;                mantissa &gt;&gt;&gt;= 1 - scaledExponent;</b>
<b class="nc">&nbsp;                if (mostSignificantLostBit != 0) {</b>
&nbsp;                    // we need to add 1 bit to round up the result
<b class="nc">&nbsp;                    mantissa++;</b>
&nbsp;                }
<b class="nc">&nbsp;                return Float.intBitsToFloat(sign | mantissa);</b>
&nbsp;
&nbsp;            } else {
&nbsp;                // no need to compute the mantissa, the number scales down to 0
<b class="nc">&nbsp;                return (sign == 0) ? 0.0f : -0.0f;</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // we are really in the case n &gt;= 128
<b class="nc">&nbsp;            if (exponent == 0) {</b>
&nbsp;
&nbsp;                // the input number is subnormal, normalize it
<b class="nc">&nbsp;                while ((mantissa &gt;&gt;&gt; 23) != 1) {</b>
<b class="nc">&nbsp;                    mantissa &lt;&lt;= 1;</b>
<b class="nc">&nbsp;                    --scaledExponent;</b>
&nbsp;                }
<b class="nc">&nbsp;                ++scaledExponent;</b>
<b class="nc">&nbsp;                mantissa &amp;= 0x007fffff;</b>
&nbsp;
<b class="nc">&nbsp;                if (scaledExponent &lt; 255) {</b>
<b class="nc">&nbsp;                    return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;            } else if (scaledExponent &lt; 255) {</b>
<b class="nc">&nbsp;                return Float.intBitsToFloat(sign | (scaledExponent &lt;&lt; 23) | mantissa);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the next machine representable number after a number, moving
&nbsp;     * in the direction of another number.
&nbsp;     * &lt;p&gt;
&nbsp;     * The ordering is as follows (increasing):
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;-INFINITY&lt;/li&gt;
&nbsp;     * &lt;li&gt;-MAX_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;-MIN_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;-0.0&lt;/li&gt;
&nbsp;     * &lt;li&gt;+0.0&lt;/li&gt;
&nbsp;     * &lt;li&gt;+MIN_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;+MAX_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;+INFINITY&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If arguments compare equal, then the second argument is returned.
&nbsp;     * &lt;p&gt;
&nbsp;     * If {@code direction} is greater than {@code d},
&nbsp;     * the smallest machine representable number strictly greater than
&nbsp;     * {@code d} is returned; if less, then the largest representable number
&nbsp;     * strictly less than {@code d} is returned.&lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If {@code d} is infinite and direction does not
&nbsp;     * bring it back to finite numbers, it is returned unchanged.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param d base number
&nbsp;     * @param direction (the only important thing is whether
&nbsp;     * {@code direction} is greater or smaller than {@code d})
&nbsp;     * @return the next machine representable number in the specified direction
&nbsp;     */
&nbsp;    public static double nextAfter(double d, double direction) {
&nbsp;        // handling of some important special cases
<b class="nc">&nbsp;        if (Double.isNaN(d) || Double.isNaN(direction)) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
<b class="nc">&nbsp;        } else if (d == direction) {</b>
<b class="nc">&nbsp;            return direction;</b>
<b class="nc">&nbsp;        } else if (Double.isInfinite(d)) {</b>
<b class="nc">&nbsp;            return (d &lt; 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;</b>
<b class="nc">&nbsp;        } else if (d == 0) {</b>
<b class="nc">&nbsp;            return (direction &lt; 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;</b>
&nbsp;        }
&nbsp;        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
&nbsp;        // are handled just as normal numbers
&nbsp;        // can use raw bits since already dealt with infinity and NaN
<b class="nc">&nbsp;        final long bits = Double.doubleToRawLongBits(d);</b>
<b class="nc">&nbsp;        final long sign = bits &amp; 0x8000000000000000L;</b>
<b class="nc">&nbsp;        if ((direction &lt; d) ^ (sign == 0L)) {</b>
<b class="nc">&nbsp;            return Double.longBitsToDouble(sign | ((bits &amp; 0x7fffffffffffffffL) + 1));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return Double.longBitsToDouble(sign | ((bits &amp; 0x7fffffffffffffffL) - 1));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the next machine representable number after a number, moving
&nbsp;     * in the direction of another number.
&nbsp;     * &lt;p&gt;
&nbsp;     * The ordering is as follows (increasing):
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;-INFINITY&lt;/li&gt;
&nbsp;     * &lt;li&gt;-MAX_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;-MIN_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;-0.0&lt;/li&gt;
&nbsp;     * &lt;li&gt;+0.0&lt;/li&gt;
&nbsp;     * &lt;li&gt;+MIN_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;+MAX_VALUE&lt;/li&gt;
&nbsp;     * &lt;li&gt;+INFINITY&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If arguments compare equal, then the second argument is returned.
&nbsp;     * &lt;p&gt;
&nbsp;     * If {@code direction} is greater than {@code f},
&nbsp;     * the smallest machine representable number strictly greater than
&nbsp;     * {@code f} is returned; if less, then the largest representable number
&nbsp;     * strictly less than {@code f} is returned.&lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If {@code f} is infinite and direction does not
&nbsp;     * bring it back to finite numbers, it is returned unchanged.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param f base number
&nbsp;     * @param direction (the only important thing is whether
&nbsp;     * {@code direction} is greater or smaller than {@code f})
&nbsp;     * @return the next machine representable number in the specified direction
&nbsp;     */
&nbsp;    public static float nextAfter(final float f, final double direction) {
&nbsp;
&nbsp;        // handling of some important special cases
<b class="nc">&nbsp;        if (Double.isNaN(f) || Double.isNaN(direction)) {</b>
<b class="nc">&nbsp;            return Float.NaN;</b>
<b class="nc">&nbsp;        } else if (f == direction) {</b>
<b class="nc">&nbsp;            return (float) direction;</b>
<b class="nc">&nbsp;        } else if (Float.isInfinite(f)) {</b>
<b class="nc">&nbsp;            return (f &lt; 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;</b>
<b class="nc">&nbsp;        } else if (f == 0f) {</b>
<b class="nc">&nbsp;            return (direction &lt; 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;</b>
&nbsp;        }
&nbsp;        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
&nbsp;        // are handled just as normal numbers
&nbsp;
<b class="nc">&nbsp;        final int bits = Float.floatToIntBits(f);</b>
<b class="nc">&nbsp;        final int sign = bits &amp; 0x80000000;</b>
<b class="nc">&nbsp;        if ((direction &lt; f) ^ (sign == 0)) {</b>
<b class="nc">&nbsp;            return Float.intBitsToFloat(sign | ((bits &amp; 0x7fffffff) + 1));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            return Float.intBitsToFloat(sign | ((bits &amp; 0x7fffffff) - 1));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Get the largest whole number smaller than x.
&nbsp;     * @param x number from which floor is requested
&nbsp;     * @return a double number f such that f is an integer f &amp;lt;= x &amp;lt; f + 1.0
&nbsp;     */
&nbsp;    public static double floor(double x) {
&nbsp;        long y;
&nbsp;
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (x &gt;= TWO_POWER_52 || x &lt;= -TWO_POWER_52) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        y = (long) x;</b>
<b class="nc">&nbsp;        if (x &lt; 0 &amp;&amp; y != x) {</b>
<b class="nc">&nbsp;            y--;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        if (y == 0) {</b>
<b class="nc">&nbsp;            return x * y;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return y;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Get the smallest whole number larger than x.
&nbsp;     * @param x number from which ceil is requested
&nbsp;     * @return a double number c such that c is an integer c - 1.0 &amp;lt; x &amp;lt;= c
&nbsp;     */
&nbsp;    public static double ceil(double x) {
&nbsp;        double y;
&nbsp;
<b class="nc">&nbsp;        if (Double.isNaN(x)) {</b>
<b class="nc">&nbsp;            return x;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        y = floor(x);</b>
<b class="nc">&nbsp;        if (y == x) {</b>
<b class="nc">&nbsp;            return y;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        y += 1.0;</b>
&nbsp;
<b class="nc">&nbsp;        if (y == 0) {</b>
<b class="nc">&nbsp;            return x * y;</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return y;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.
&nbsp;     * @param x number from which nearest whole number is requested
&nbsp;     * @return a double number r such that r is an integer r - 0.5 &amp;lt;= x &amp;lt;= r + 0.5
&nbsp;     */
&nbsp;    public static double rint(double x) {
<b class="nc">&nbsp;        double y = floor(x);</b>
<b class="nc">&nbsp;        double d = x - y;</b>
&nbsp;
<b class="nc">&nbsp;        if (d &gt; 0.5) {</b>
<b class="nc">&nbsp;            if (y == -1.0) {</b>
<b class="nc">&nbsp;                return -0.0; // Preserve sign of operand</b>
&nbsp;            }
<b class="nc">&nbsp;            return y + 1.0;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (d &lt; 0.5) {</b>
<b class="nc">&nbsp;            return y;</b>
&nbsp;        }
&nbsp;
&nbsp;        /* half way, round to even */
<b class="nc">&nbsp;        long z = (long) y;</b>
<b class="nc">&nbsp;        return (z &amp; 1) == 0 ? y : y + 1.0;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Get the closest long to x.
&nbsp;     * @param x number from which closest long is requested
&nbsp;     * @return closest long to x
&nbsp;     */
&nbsp;    public static long round(double x) {
<b class="nc">&nbsp;        final long bits = Double.doubleToRawLongBits(x);</b>
<b class="nc">&nbsp;        final int biasedExp = ((int) (bits &gt;&gt; 52)) &amp; 0x7ff;</b>
&nbsp;        // Shift to get rid of bits past comma except first one: will need to
&nbsp;        // 1-shift to the right to end up with correct magnitude.
<b class="nc">&nbsp;        final int shift = (52 - 1 + Double.MAX_EXPONENT) - biasedExp;</b>
<b class="nc">&nbsp;        if ((shift &amp; -64) == 0) {</b>
&nbsp;            // shift in [0,63], so unbiased exp in [-12,51].
<b class="nc">&nbsp;            long extendedMantissa = 0x0010000000000000L | (bits &amp; 0x000fffffffffffffL);</b>
<b class="nc">&nbsp;            if (bits &lt; 0) {</b>
<b class="nc">&nbsp;                extendedMantissa = -extendedMantissa;</b>
&nbsp;            }
&nbsp;            // If value is positive and first bit past comma is 0, rounding
&nbsp;            // to lower integer, else to upper one, which is what &quot;+1&quot; and
&nbsp;            // then &quot;&gt;&gt;1&quot; do.
<b class="nc">&nbsp;            return ((extendedMantissa &gt;&gt; shift) + 1L) &gt;&gt; 1;</b>
&nbsp;        } else {
&nbsp;            // +-Infinity, NaN, or a mathematical integer.
<b class="nc">&nbsp;            return (long) x;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Get the closest int to x.
&nbsp;     * @param x number from which closest int is requested
&nbsp;     * @return closest int to x
&nbsp;     */
&nbsp;    public static int round(final float x) {
<b class="nc">&nbsp;        final int bits = Float.floatToRawIntBits(x);</b>
<b class="nc">&nbsp;        final int biasedExp = (bits &gt;&gt; 23) &amp; 0xff;</b>
&nbsp;        // Shift to get rid of bits past comma except first one: will need to
&nbsp;        // 1-shift to the right to end up with correct magnitude.
<b class="nc">&nbsp;        final int shift = (23 - 1 + Float.MAX_EXPONENT) - biasedExp;</b>
<b class="nc">&nbsp;        if ((shift &amp; -32) == 0) {</b>
&nbsp;            // shift in [0,31], so unbiased exp in [-9,22].
<b class="nc">&nbsp;            int extendedMantissa = 0x00800000 | (bits &amp; 0x007fffff);</b>
<b class="nc">&nbsp;            if (bits &lt; 0) {</b>
<b class="nc">&nbsp;                extendedMantissa = -extendedMantissa;</b>
&nbsp;            }
&nbsp;            // If value is positive and first bit past comma is 0, rounding
&nbsp;            // to lower integer, else to upper one, which is what &quot;+1&quot; and
&nbsp;            // then &quot;&gt;&gt;1&quot; do.
<b class="nc">&nbsp;            return ((extendedMantissa &gt;&gt; shift) + 1) &gt;&gt; 1;</b>
&nbsp;        } else {
&nbsp;            // +-Infinity, NaN, or a mathematical integer.
<b class="nc">&nbsp;            return (int) x;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the minimum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return a if a is lesser or equal to b, b otherwise
&nbsp;     */
&nbsp;    public static int min(final int a, final int b) {
<b class="nc">&nbsp;        return (a &lt;= b) ? a : b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the minimum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return a if a is lesser or equal to b, b otherwise
&nbsp;     */
&nbsp;    public static long min(final long a, final long b) {
<b class="nc">&nbsp;        return (a &lt;= b) ? a : b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the minimum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return a if a is lesser or equal to b, b otherwise
&nbsp;     */
&nbsp;    public static float min(final float a, final float b) {
<b class="nc">&nbsp;        if (a &gt; b) {</b>
<b class="nc">&nbsp;            return b;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (a &lt; b) {</b>
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
&nbsp;        /* if either arg is NaN, return NaN */
<b class="nc">&nbsp;        if (a != b) {</b>
<b class="nc">&nbsp;            return Float.NaN;</b>
&nbsp;        }
&nbsp;        /* min(+0.0,-0.0) == -0.0 */
&nbsp;        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
<b class="nc">&nbsp;        int bits = Float.floatToRawIntBits(a);</b>
<b class="nc">&nbsp;        if (bits == 0x80000000) {</b>
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
<b class="nc">&nbsp;        return b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the minimum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return a if a is lesser or equal to b, b otherwise
&nbsp;     */
&nbsp;    public static double min(final double a, final double b) {
<b class="nc">&nbsp;        if (a &gt; b) {</b>
<b class="nc">&nbsp;            return b;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (a &lt; b) {</b>
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
&nbsp;        /* if either arg is NaN, return NaN */
<b class="nc">&nbsp;        if (a != b) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;        /* min(+0.0,-0.0) == -0.0 */
&nbsp;        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
<b class="nc">&nbsp;        long bits = Double.doubleToRawLongBits(a);</b>
<b class="nc">&nbsp;        if (bits == 0x8000000000000000L) {</b>
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
<b class="nc">&nbsp;        return b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the maximum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return b if a is lesser or equal to b, a otherwise
&nbsp;     */
&nbsp;    public static int max(final int a, final int b) {
<b class="fc">&nbsp;        return (a &lt;= b) ? b : a;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the maximum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return b if a is lesser or equal to b, a otherwise
&nbsp;     */
&nbsp;    public static long max(final long a, final long b) {
<b class="nc">&nbsp;        return (a &lt;= b) ? b : a;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the maximum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return b if a is lesser or equal to b, a otherwise
&nbsp;     */
&nbsp;    public static float max(final float a, final float b) {
<b class="nc">&nbsp;        if (a &gt; b) {</b>
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (a &lt; b) {</b>
<b class="nc">&nbsp;            return b;</b>
&nbsp;        }
&nbsp;        /* if either arg is NaN, return NaN */
<b class="nc">&nbsp;        if (a != b) {</b>
<b class="nc">&nbsp;            return Float.NaN;</b>
&nbsp;        }
&nbsp;        /* min(+0.0,-0.0) == -0.0 */
&nbsp;        /* 0x80000000 == Float.floatToRawIntBits(-0.0d) */
<b class="nc">&nbsp;        int bits = Float.floatToRawIntBits(a);</b>
<b class="nc">&nbsp;        if (bits == 0x80000000) {</b>
<b class="nc">&nbsp;            return b;</b>
&nbsp;        }
<b class="nc">&nbsp;        return a;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Compute the maximum of two values.
&nbsp;     * @param a first value
&nbsp;     * @param b second value
&nbsp;     * @return b if a is lesser or equal to b, a otherwise
&nbsp;     */
&nbsp;    public static double max(final double a, final double b) {
<b class="fc">&nbsp;        if (a &gt; b) {</b>
<b class="nc">&nbsp;            return a;</b>
&nbsp;        }
<b class="fc">&nbsp;        if (a &lt; b) {</b>
<b class="fc">&nbsp;            return b;</b>
&nbsp;        }
&nbsp;        /* if either arg is NaN, return NaN */
<b class="fc">&nbsp;        if (a != b) {</b>
<b class="fc">&nbsp;            return Double.NaN;</b>
&nbsp;        }
&nbsp;        /* min(+0.0,-0.0) == -0.0 */
&nbsp;        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */
<b class="fc">&nbsp;        long bits = Double.doubleToRawLongBits(a);</b>
<b class="fc">&nbsp;        if (bits == 0x8000000000000000L) {</b>
<b class="nc">&nbsp;            return b;</b>
&nbsp;        }
<b class="fc">&nbsp;        return a;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}
&nbsp;     * - sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)&lt;br&gt;
&nbsp;     * avoiding intermediate overflow or underflow.
&nbsp;     *
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt; If either argument is infinite, then the result is positive infinity.&lt;/li&gt;
&nbsp;     * &lt;li&gt; else, if either argument is NaN then the result is NaN.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     *
&nbsp;     * @param x a value
&nbsp;     * @param y a value
&nbsp;     * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
&nbsp;     */
&nbsp;    public static double hypot(final double x, final double y) {
<b class="nc">&nbsp;        if (Double.isInfinite(x) || Double.isInfinite(y)) {</b>
<b class="nc">&nbsp;            return Double.POSITIVE_INFINITY;</b>
<b class="nc">&nbsp;        } else if (Double.isNaN(x) || Double.isNaN(y)) {</b>
<b class="nc">&nbsp;            return Double.NaN;</b>
&nbsp;        } else {
<b class="nc">&nbsp;            final int expX = getExponent(x);</b>
<b class="nc">&nbsp;            final int expY = getExponent(y);</b>
<b class="nc">&nbsp;            if (expX &gt; expY + 27) {</b>
&nbsp;                // y is neglectible with respect to x
<b class="nc">&nbsp;                return abs(x);</b>
<b class="nc">&nbsp;            } else if (expY &gt; expX + 27) {</b>
&nbsp;                // x is neglectible with respect to y
<b class="nc">&nbsp;                return abs(y);</b>
&nbsp;            } else {
&nbsp;                // find an intermediate scale to avoid both overflow and underflow
<b class="nc">&nbsp;                final int middleExp = (expX + expY) / 2;</b>
&nbsp;
&nbsp;                // scale parameters without losing precision
<b class="nc">&nbsp;                final double scaledX = scalb(x, -middleExp);</b>
<b class="nc">&nbsp;                final double scaledY = scalb(y, -middleExp);</b>
&nbsp;
&nbsp;                // compute scaled hypotenuse
<b class="nc">&nbsp;                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);</b>
&nbsp;
&nbsp;                // remove scaling
<b class="nc">&nbsp;                return scalb(scaledH, middleExp);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Computes the remainder as prescribed by the IEEE 754 standard.
&nbsp;     * The remainder value is mathematically equal to {@code x - y*n}
&nbsp;     * where {@code n} is the mathematical integer closest to the exact mathematical value
&nbsp;     * of the quotient {@code x/y}.
&nbsp;     * If two mathematical integers are equally close to {@code x/y} then
&nbsp;     * {@code n} is the integer that is even.
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;If either operand is NaN, the result is NaN.&lt;/li&gt;
&nbsp;     * &lt;li&gt;If the result is not NaN, the sign of the result equals the sign of the dividend.&lt;/li&gt;
&nbsp;     * &lt;li&gt;If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.&lt;/li&gt;
&nbsp;     * &lt;li&gt;If the dividend is finite and the divisor is an infinity, the result equals the dividend.&lt;/li&gt;
&nbsp;     * &lt;li&gt;If the dividend is a zero and the divisor is finite, the result equals the dividend.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * @param dividend the number to be divided
&nbsp;     * @param divisor the number by which to divide
&nbsp;     * @return the remainder, rounded
&nbsp;     */
&nbsp;    public static double IEEEremainder(final double dividend, final double divisor) {
<b class="nc">&nbsp;        if (getExponent(dividend) == 1024 || getExponent(divisor) == 1024 || divisor == 0.0) {</b>
&nbsp;            // we are in one of the special cases
<b class="nc">&nbsp;            if (Double.isInfinite(divisor) &amp;&amp; !Double.isInfinite(dividend)) {</b>
<b class="nc">&nbsp;                return dividend;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return Double.NaN;</b>
&nbsp;            }
&nbsp;        } else {
&nbsp;            // we are in the general case
<b class="nc">&nbsp;            final double n         = AccurateMath.rint(dividend / divisor);</b>
<b class="nc">&nbsp;            final double remainder = Double.isInfinite(n) ? 0.0 : dividend - divisor * n;</b>
<b class="nc">&nbsp;            return (remainder == 0) ? AccurateMath.copySign(remainder, dividend) : remainder;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Convert a long to integer, detecting overflows.
&nbsp;     * @param n number to convert to int
&nbsp;     * @return integer with same value as n if no overflows occur
&nbsp;     * @exception MathArithmeticException if n cannot fit into an int
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int toIntExact(final long n) throws MathArithmeticException {
<b class="nc">&nbsp;        if (n &lt; Integer.MIN_VALUE || n &gt; Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW);</b>
&nbsp;        }
<b class="nc">&nbsp;        return (int) n;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Increment a number, detecting overflows.
&nbsp;     * @param n number to increment
&nbsp;     * @return n+1 if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int incrementExact(final int n) throws MathArithmeticException {
<b class="nc">&nbsp;        if (n == Integer.MAX_VALUE) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return n + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Increment a number, detecting overflows.
&nbsp;     * @param n number to increment
&nbsp;     * @return n+1 if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long incrementExact(final long n) throws MathArithmeticException {
<b class="nc">&nbsp;        if (n == Long.MAX_VALUE) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, n, 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return n + 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Decrement a number, detecting overflows.
&nbsp;     * @param n number to decrement
&nbsp;     * @return n-1 if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int decrementExact(final int n) throws MathArithmeticException {
<b class="nc">&nbsp;        if (n == Integer.MIN_VALUE) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return n - 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Decrement a number, detecting overflows.
&nbsp;     * @param n number to decrement
&nbsp;     * @return n-1 if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long decrementExact(final long n) throws MathArithmeticException {
<b class="nc">&nbsp;        if (n == Long.MIN_VALUE) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, n, 1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return n - 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Add two numbers, detecting overflows.
&nbsp;     * @param a first number to add
&nbsp;     * @param b second number to add
&nbsp;     * @return a+b if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int addExact(final int a, final int b) throws MathArithmeticException {
&nbsp;        // compute sum
<b class="nc">&nbsp;        final int sum = a + b;</b>
&nbsp;
&nbsp;        // check for overflow
<b class="nc">&nbsp;        if ((a ^ b) &gt;= 0 &amp;&amp; (sum ^ b) &lt; 0) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return sum;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Add two numbers, detecting overflows.
&nbsp;     * @param a first number to add
&nbsp;     * @param b second number to add
&nbsp;     * @return a+b if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long addExact(final long a, final long b) throws MathArithmeticException {
&nbsp;        // compute sum
<b class="nc">&nbsp;        final long sum = a + b;</b>
&nbsp;
&nbsp;        // check for overflow
<b class="nc">&nbsp;        if ((a ^ b) &gt;= 0 &amp;&amp; (sum ^ b) &lt; 0) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, b);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return sum;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Subtract two numbers, detecting overflows.
&nbsp;     * @param a first number
&nbsp;     * @param b second number to subtract from a
&nbsp;     * @return a-b if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int subtractExact(final int a, final int b) {
&nbsp;        // compute subtraction
<b class="nc">&nbsp;        final int sub = a - b;</b>
&nbsp;
&nbsp;        // check for overflow
<b class="nc">&nbsp;        if ((a ^ b) &lt; 0 &amp;&amp; (sub ^ b) &gt;= 0) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return sub;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Subtract two numbers, detecting overflows.
&nbsp;     * @param a first number
&nbsp;     * @param b second number to subtract from a
&nbsp;     * @return a-b if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long subtractExact(final long a, final long b) {
&nbsp;        // compute subtraction
<b class="nc">&nbsp;        final long sub = a - b;</b>
&nbsp;
&nbsp;        // check for overflow
<b class="nc">&nbsp;        if ((a ^ b) &lt; 0 &amp;&amp; (sub ^ b) &gt;= 0) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, a, b);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return sub;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Multiply two numbers, detecting overflows.
&nbsp;     * @param a first number to multiply
&nbsp;     * @param b second number to multiply
&nbsp;     * @return a*b if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int multiplyExact(final int a, final int b) {
<b class="nc">&nbsp;        if (((b  &gt;  0)  &amp;&amp; (a &gt; Integer.MAX_VALUE / b || a &lt; Integer.MIN_VALUE / b)) ||</b>
&nbsp;            ((b  &lt; -1)  &amp;&amp; (a &gt; Integer.MIN_VALUE / b || a &lt; Integer.MAX_VALUE / b)) ||
&nbsp;            ((b == -1)  &amp;&amp; (a == Integer.MIN_VALUE))) {
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);</b>
&nbsp;        }
<b class="nc">&nbsp;        return a * b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Multiply two numbers, detecting overflows.
&nbsp;     * @param a first number to multiply
&nbsp;     * @param b second number to multiply
&nbsp;     * @return a*b if no overflows occur
&nbsp;     * @exception MathArithmeticException if an overflow occurs
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long multiplyExact(final long a, final long b) {
<b class="nc">&nbsp;        if (((b  &gt;  0L)  &amp;&amp; (a &gt; Long.MAX_VALUE / b || a &lt; Long.MIN_VALUE / b)) ||</b>
&nbsp;            ((b  &lt; -1L)  &amp;&amp; (a &gt; Long.MIN_VALUE / b || a &lt; Long.MAX_VALUE / b)) ||
&nbsp;            ((b == -1L)  &amp;&amp; (a == Long.MIN_VALUE))) {
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_MULTIPLICATION, a, b);</b>
&nbsp;        }
<b class="nc">&nbsp;        return a * b;</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Finds q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
&nbsp;     * &lt;p&gt;
&nbsp;     * This methods returns the same value as integer division when
&nbsp;     * a and b are same signs, but returns a different value when
&nbsp;     * they are opposite (i.e. q is negative).
&nbsp;     * &lt;/p&gt;
&nbsp;     * @param a dividend
&nbsp;     * @param b divisor
&nbsp;     * @return q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
&nbsp;     * @exception MathArithmeticException if b == 0
&nbsp;     * @see #floorMod(int, int)
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int floorDiv(final int a, final int b) throws MathArithmeticException {
<b class="nc">&nbsp;        if (b == 0) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int m = a % b;</b>
<b class="nc">&nbsp;        if ((a ^ b) &gt;= 0 || m == 0) {</b>
&nbsp;            // a an b have same sign, or division is exact
<b class="nc">&nbsp;            return a / b;</b>
&nbsp;        } else {
&nbsp;            // a and b have opposite signs and division is not exact
<b class="nc">&nbsp;            return (a / b) - 1;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Finds q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
&nbsp;     * &lt;p&gt;
&nbsp;     * This methods returns the same value as integer division when
&nbsp;     * a and b are same signs, but returns a different value when
&nbsp;     * they are opposite (i.e. q is negative).
&nbsp;     * &lt;/p&gt;
&nbsp;     * @param a dividend
&nbsp;     * @param b divisor
&nbsp;     * @return q such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
&nbsp;     * @exception MathArithmeticException if b == 0
&nbsp;     * @see #floorMod(long, long)
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long floorDiv(final long a, final long b) throws MathArithmeticException {
<b class="nc">&nbsp;        if (b == 0L) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final long m = a % b;</b>
<b class="nc">&nbsp;        if ((a ^ b) &gt;= 0L || m == 0L) {</b>
&nbsp;            // a an b have same sign, or division is exact
<b class="nc">&nbsp;            return a / b;</b>
&nbsp;        } else {
&nbsp;            // a and b have opposite signs and division is not exact
<b class="nc">&nbsp;            return (a / b) - 1L;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Finds r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
&nbsp;     * &lt;p&gt;
&nbsp;     * This methods returns the same value as integer modulo when
&nbsp;     * a and b are same signs, but returns a different value when
&nbsp;     * they are opposite (i.e. q is negative).
&nbsp;     * &lt;/p&gt;
&nbsp;     * @param a dividend
&nbsp;     * @param b divisor
&nbsp;     * @return r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
&nbsp;     * @exception MathArithmeticException if b == 0
&nbsp;     * @see #floorDiv(int, int)
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static int floorMod(final int a, final int b) throws MathArithmeticException {
<b class="nc">&nbsp;        if (b == 0) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final int m = a % b;</b>
<b class="nc">&nbsp;        if ((a ^ b) &gt;= 0 || m == 0) {</b>
&nbsp;            // a an b have same sign, or division is exact
<b class="nc">&nbsp;            return m;</b>
&nbsp;        } else {
&nbsp;            // a and b have opposite signs and division is not exact
<b class="nc">&nbsp;            return b + m;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Finds r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0.
&nbsp;     * &lt;p&gt;
&nbsp;     * This methods returns the same value as integer modulo when
&nbsp;     * a and b are same signs, but returns a different value when
&nbsp;     * they are opposite (i.e. q is negative).
&nbsp;     * &lt;/p&gt;
&nbsp;     * @param a dividend
&nbsp;     * @param b divisor
&nbsp;     * @return r such that a = q b + r with 0 &amp;lt;= r &amp;lt; b if b &amp;gt; 0 and b &amp;lt; r &amp;lt;= 0 if b &amp;lt; 0
&nbsp;     * @exception MathArithmeticException if b == 0
&nbsp;     * @see #floorDiv(long, long)
&nbsp;     * @since 3.4
&nbsp;     */
&nbsp;    public static long floorMod(final long a, final long b) {
<b class="nc">&nbsp;        if (b == 0L) {</b>
<b class="nc">&nbsp;            throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR);</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        final long m = a % b;</b>
<b class="nc">&nbsp;        if ((a ^ b) &gt;= 0L || m == 0L) {</b>
&nbsp;            // a an b have same sign, or division is exact
<b class="nc">&nbsp;            return m;</b>
&nbsp;        } else {
&nbsp;            // a and b have opposite signs and division is not exact
<b class="nc">&nbsp;            return b + m;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first argument with the sign of the second argument.
&nbsp;     * A NaN {@code sign} argument is treated as positive.
&nbsp;     *
&nbsp;     * @param magnitude the value to return
&nbsp;     * @param sign the sign for the returned value
&nbsp;     * @return the magnitude with the same sign as the {@code sign} argument
&nbsp;     */
&nbsp;    public static double copySign(double magnitude, double sign) {
&nbsp;        // The highest order bit is going to be zero if the
&nbsp;        // highest order bit of m and s is the same and one otherwise.
&nbsp;        // So (m^s) will be positive if both m and s have the same sign
&nbsp;        // and negative otherwise.
<b class="nc">&nbsp;        final long m = Double.doubleToRawLongBits(magnitude); // don&#39;t care about NaN</b>
<b class="nc">&nbsp;        final long s = Double.doubleToRawLongBits(sign);</b>
<b class="nc">&nbsp;        if ((m ^ s) &gt;= 0) {</b>
<b class="nc">&nbsp;            return magnitude;</b>
&nbsp;        }
<b class="nc">&nbsp;        return -magnitude; // flip sign</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the first argument with the sign of the second argument.
&nbsp;     * A NaN {@code sign} argument is treated as positive.
&nbsp;     *
&nbsp;     * @param magnitude the value to return
&nbsp;     * @param sign the sign for the returned value
&nbsp;     * @return the magnitude with the same sign as the {@code sign} argument
&nbsp;     */
&nbsp;    public static float copySign(float magnitude, float sign) {
&nbsp;        // The highest order bit is going to be zero if the
&nbsp;        // highest order bit of m and s is the same and one otherwise.
&nbsp;        // So (m^s) will be positive if both m and s have the same sign
&nbsp;        // and negative otherwise.
<b class="nc">&nbsp;        final int m = Float.floatToRawIntBits(magnitude);</b>
<b class="nc">&nbsp;        final int s = Float.floatToRawIntBits(sign);</b>
<b class="nc">&nbsp;        if ((m ^ s) &gt;= 0) {</b>
<b class="nc">&nbsp;            return magnitude;</b>
&nbsp;        }
<b class="nc">&nbsp;        return -magnitude; // flip sign</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the exponent of a double number, removing the bias.
&nbsp;     * &lt;p&gt;
&nbsp;     * For double numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
&nbsp;     * exponent is exactly x.
&nbsp;     * &lt;/p&gt;
&nbsp;     * @param d number from which exponent is requested
&nbsp;     * @return exponent for d in IEEE754 representation, without bias
&nbsp;     */
&nbsp;    public static int getExponent(final double d) {
&nbsp;        // NaN and Infinite will return 1024 anywho so can use raw bits
<b class="nc">&nbsp;        return (int) ((Double.doubleToRawLongBits(d) &gt;&gt;&gt; 52) &amp; 0x7ff) - 1023;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return the exponent of a float number, removing the bias.
&nbsp;     * &lt;p&gt;
&nbsp;     * For float numbers of the form 2&lt;sup&gt;x&lt;/sup&gt;, the unbiased
&nbsp;     * exponent is exactly x.
&nbsp;     * &lt;/p&gt;
&nbsp;     * @param f number from which exponent is requested
&nbsp;     * @return exponent for d in IEEE754 representation, without bias
&nbsp;     */
&nbsp;    public static int getExponent(final float f) {
&nbsp;        // NaN and Infinite will return the same exponent anywho so can use raw bits
<b class="nc">&nbsp;        return ((Float.floatToRawIntBits(f) &gt;&gt;&gt; 23) &amp; 0xff) - 127;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Print out contents of arrays, and check the length.
&nbsp;     * &lt;p&gt;used to generate the preset arrays originally.&lt;/p&gt;
&nbsp;     * @param a unused
&nbsp;     */
&nbsp;    public static void main(String[] a) {
<b class="nc">&nbsp;        PrintStream out = System.out;</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;EXP_INT_TABLE_A&quot;, EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;EXP_INT_TABLE_B&quot;, EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;EXP_FRAC_TABLE_A&quot;, EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;EXP_FRAC_TABLE_B&quot;, EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;LN_MANT&quot;, LN_MANT_LEN, lnMant.LN_MANT);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;SINE_TABLE_A&quot;, SINE_TABLE_LEN, SINE_TABLE_A);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;SINE_TABLE_B&quot;, SINE_TABLE_LEN, SINE_TABLE_B);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;COSINE_TABLE_A&quot;, SINE_TABLE_LEN, COSINE_TABLE_A);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;COSINE_TABLE_B&quot;, SINE_TABLE_LEN, COSINE_TABLE_B);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;TANGENT_TABLE_A&quot;, SINE_TABLE_LEN, TANGENT_TABLE_A);</b>
<b class="nc">&nbsp;        AccurateMathCalc.printarray(out, &quot;TANGENT_TABLE_B&quot;, SINE_TABLE_LEN, TANGENT_TABLE_B);</b>
&nbsp;    }
&nbsp;
&nbsp;    /** Enclose large data table in nested static class so it&#39;s only loaded on first access. */
&nbsp;    private static class ExpIntTable {
&nbsp;        /** Exponential evaluated at integer values,
&nbsp;         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].
&nbsp;         */
&nbsp;        private static final double[] EXP_INT_TABLE_A;
&nbsp;        /** Exponential evaluated at integer values.
&nbsp;         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]
&nbsp;         */
&nbsp;        private static final double[] EXP_INT_TABLE_B;
&nbsp;
&nbsp;        static {
&nbsp;            if (RECOMPUTE_TABLES_AT_RUNTIME) {
&nbsp;                EXP_INT_TABLE_A = new double[AccurateMath.EXP_INT_TABLE_LEN];
&nbsp;                EXP_INT_TABLE_B = new double[AccurateMath.EXP_INT_TABLE_LEN];
&nbsp;
&nbsp;                final double[] tmp = new double[2];
&nbsp;                final double[] recip = new double[2];
&nbsp;
&nbsp;                // Populate expIntTable
&nbsp;                for (int i = 0; i &lt; AccurateMath.EXP_INT_TABLE_MAX_INDEX; i++) {
&nbsp;                    AccurateMathCalc.expint(i, tmp);
&nbsp;                    EXP_INT_TABLE_A[i + AccurateMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];
&nbsp;                    EXP_INT_TABLE_B[i + AccurateMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];
&nbsp;
&nbsp;                    if (i != 0) {
&nbsp;                        // Negative integer powers
&nbsp;                        AccurateMathCalc.splitReciprocal(tmp, recip);
&nbsp;                        EXP_INT_TABLE_A[AccurateMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];
&nbsp;                        EXP_INT_TABLE_B[AccurateMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];
&nbsp;                    }
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                EXP_INT_TABLE_A = AccurateMathLiteralArrays.loadExpIntA();</b>
<b class="nc">&nbsp;                EXP_INT_TABLE_B = AccurateMathLiteralArrays.loadExpIntB();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Enclose large data table in nested static class so it&#39;s only loaded on first access. */
&nbsp;    private static class ExpFracTable {
&nbsp;        /** Exponential over the range of 0 - 1 in increments of 2^-10
&nbsp;         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
&nbsp;         * 1024 = 2^10
&nbsp;         */
&nbsp;        private static final double[] EXP_FRAC_TABLE_A;
&nbsp;        /** Exponential over the range of 0 - 1 in increments of 2^-10
&nbsp;         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].
&nbsp;         */
&nbsp;        private static final double[] EXP_FRAC_TABLE_B;
&nbsp;
&nbsp;        static {
&nbsp;            if (RECOMPUTE_TABLES_AT_RUNTIME) {
&nbsp;                EXP_FRAC_TABLE_A = new double[AccurateMath.EXP_FRAC_TABLE_LEN];
&nbsp;                EXP_FRAC_TABLE_B = new double[AccurateMath.EXP_FRAC_TABLE_LEN];
&nbsp;
&nbsp;                final double[] tmp = new double[2];
&nbsp;
&nbsp;                // Populate expFracTable
&nbsp;                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);
&nbsp;                for (int i = 0; i &lt; EXP_FRAC_TABLE_A.length; i++) {
&nbsp;                    AccurateMathCalc.slowexp(i * factor, tmp);
&nbsp;                    EXP_FRAC_TABLE_A[i] = tmp[0];
&nbsp;                    EXP_FRAC_TABLE_B[i] = tmp[1];
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                EXP_FRAC_TABLE_A = AccurateMathLiteralArrays.loadExpFracA();</b>
<b class="nc">&nbsp;                EXP_FRAC_TABLE_B = AccurateMathLiteralArrays.loadExpFracB();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Enclose large data table in nested static class so it&#39;s only loaded on first access. */
&nbsp;    private static class lnMant {
&nbsp;        /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */
&nbsp;        private static final double[][] LN_MANT;
&nbsp;
&nbsp;        static {
&nbsp;            if (RECOMPUTE_TABLES_AT_RUNTIME) {
&nbsp;                LN_MANT = new double[AccurateMath.LN_MANT_LEN][];
&nbsp;
&nbsp;                // Populate lnMant table
&nbsp;                for (int i = 0; i &lt; LN_MANT.length; i++) {
&nbsp;                    final double d = Double.longBitsToDouble((((long) i) &lt;&lt; 42) | 0x3ff0000000000000L);
&nbsp;                    LN_MANT[i] = AccurateMathCalc.slowLog(d);
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                LN_MANT = AccurateMathLiteralArrays.loadLnMant();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /** Enclose the Cody/Waite reduction (used in &quot;sin&quot;, &quot;cos&quot; and &quot;tan&quot;). */
&nbsp;    private static class CodyWaite {
&nbsp;        /** k. */
&nbsp;        private final int finalK;
&nbsp;        /** remA. */
&nbsp;        private final double finalRemA;
&nbsp;        /** remB. */
&nbsp;        private final double finalRemB;
&nbsp;
&nbsp;        /**
&nbsp;         * @param xa Argument.
&nbsp;         */
<b class="nc">&nbsp;        CodyWaite(double xa) {</b>
&nbsp;            // Estimate k.
&nbsp;            //k = (int)(xa / 1.5707963267948966);
<b class="nc">&nbsp;            int k = (int)(xa * 0.6366197723675814);</b>
&nbsp;
&nbsp;            // Compute remainder.
&nbsp;            double remA;
&nbsp;            double remB;
&nbsp;            while (true) {
<b class="nc">&nbsp;                double a = -k * 1.570796251296997;</b>
<b class="nc">&nbsp;                remA = xa + a;</b>
<b class="nc">&nbsp;                remB = -(remA - xa - a);</b>
&nbsp;
<b class="nc">&nbsp;                a = -k * 7.549789948768648E-8;</b>
<b class="nc">&nbsp;                double b = remA;</b>
<b class="nc">&nbsp;                remA = a + b;</b>
<b class="nc">&nbsp;                remB += -(remA - b - a);</b>
&nbsp;
<b class="nc">&nbsp;                a = -k * 6.123233995736766E-17;</b>
<b class="nc">&nbsp;                b = remA;</b>
<b class="nc">&nbsp;                remA = a + b;</b>
<b class="nc">&nbsp;                remB += -(remA - b - a);</b>
&nbsp;
<b class="nc">&nbsp;                if (remA &gt; 0) {</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;
&nbsp;                // Remainder is negative, so decrement k and try again.
&nbsp;                // This should only happen if the input is very close
&nbsp;                // to an even multiple of pi/2.
<b class="nc">&nbsp;                --k;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;
<b class="nc">&nbsp;            this.finalK = k;</b>
<b class="nc">&nbsp;            this.finalRemA = remA;</b>
<b class="nc">&nbsp;            this.finalRemB = remB;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * @return k
&nbsp;         */
&nbsp;        int getK() {
<b class="nc">&nbsp;            return finalK;</b>
&nbsp;        }
&nbsp;        /**
&nbsp;         * @return remA
&nbsp;         */
&nbsp;        double getRemA() {
<b class="nc">&nbsp;            return finalRemA;</b>
&nbsp;        }
&nbsp;        /**
&nbsp;         * @return remB
&nbsp;         */
&nbsp;        double getRemB() {
<b class="nc">&nbsp;            return finalRemB;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-08-14 14:22</div>
</div>
</body>
</html>
